<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Students - St. Patrick's Progress Card App</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
  <style>
    html, body { margin: 0; padding: 0; font-family: 'Segoe UI', Arial, sans-serif; background: #f4f8fc; min-height: 100vh; min-width: 100vw; overflow-x: hidden; }
    .fixed-header {
  background: #0f3d6b; 
  color: #fff; 
  text-align: center; 
  padding: 18px 0 8px 0; 
  border-bottom-left-radius: 14px; 
  border-bottom-right-radius: 14px; 
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 100;
  width: 100%;
}
    .fixed-header .school-title { color: #fff; font-size: 1.5em; margin: 0; }
    .fixed-header .subtitle { color: #c9e4ff; font-size: .99em; font-weight: 400; margin: 0; }
    .fixed-header #header-exam { font-size: 1.13em; font-weight: bold; color: #fdc600; margin: 6px 0 0 0; }
    .main-content { 
      padding: 18px 10px 80px 10px; 
      max-width: 510px; 
      margin: 0 auto; 
      min-height: 60vh; 
      margin-top: 88px;  /* <-- adjust to your header height (try 70px, 80px, 90px as needed) */
    }
    .screen-title { font-size: 1.4em; font-weight: bold; text-align: left; color: #0f3d6b; margin-bottom: 12px; margin-top: 18px; letter-spacing: 0.5px; }
    .student-list { display: flex; flex-direction: column; gap: 7px; margin-top: 14px; }
    .student-row { background: #fff; border-radius: 12px; padding: 10px 16px; margin-bottom: 0px; box-shadow: 0 1px 5px #0f3d6b15; font-size: 1.09em; font-weight: 500; display: flex; align-items: center; justify-content: flex-start; cursor: pointer; transition: box-shadow .13s; }
    .student-row:hover { box-shadow: 0 2px 10px #0f3d6b25; background: #f7fafd; }
    .roll-no { display: inline-block; min-width: 30px; font-weight: bold; color: #1467b7; }
    .student-faded { color: #999; font-size: 0.96em; margin-left: 10px; }
    .deleted-student { text-decoration: line-through; opacity: 0.5; }
    .fab, .settings-btn { position: fixed; right: 22px; width: 44px; height: 44px; border-radius: 50%; background: #0f3d6b; box-shadow: 0 4px 18px #0f3d6b30; display: flex; align-items: center; justify-content: center; z-index: 104; border: none; cursor: pointer; transition: background 0.18s, box-shadow 0.18s; color: #fff; font-size: 1.75em; }
    .fab { bottom: 30px; }
    .fab:active, .settings-btn:active { background: #195084; box-shadow: 0 2px 8px #0f3d6b44; }
    .fab::before { content: "+"; display: block; font-size: 1.1em; font-weight: bold; color: #fff; line-height: 1; text-align: center; }
    .settings-btn { bottom: 86px; }
    .settings-btn i { color: #fff !important; font-size: 0.95em; pointer-events: none; margin: 0; padding: 0; }
    #popup-bg { position: fixed; left: 0; top: 0; right: 0; bottom: 0; background: #0007; z-index: 2001; display: none; align-items: center; justify-content: center; }
    #popup-bg.show { display: flex !important; }
    #popup-content {
  background: #fff;
  border-radius: 15px;
  box-shadow: 0 8px 30px #0f3d6b22;
  padding: 22px 18px 18px 18px;
  min-width: 270px;
  max-width: 94vw;
  width: 350px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  align-items: stretch;

  /* make the popup scroll if content is tall */
  max-height: 85vh;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: contain;
}
    .popup-title { font-size: 1.13em; color: #0f3d6b; font-weight: 700; margin-bottom: 9px; }
    #popup-content label { font-weight: 600; color: #195084; margin-bottom: 4px; }
    #popup-content input, #popup-content select { padding: 9px 11px; font-size: 1.07em; border-radius: 7px; border: 1.3px solid #c7d7ea; background: #f7fafd; margin-bottom: 13px; transition: border-color .2s; }
    #popup-content input:focus, #popup-content select:focus { outline: none; border-color: #0f3d6b; }
    .popup-btn-row { display: flex; justify-content: flex-end; gap: 8px; margin-top: 8px; }
    .popup-cancel-btn { background: #e0e0e0; color: #444; font-weight: 500; border: none; border-radius: 8px; padding: 10px 18px; cursor: pointer; transition: background .14s; }
    .popup-action-btn { background: #0f3d6b; color: #fff; border: none; border-radius: 8px; padding: 10px 18px; font-weight: bold; cursor: pointer; transition: background .14s; }
    .popup-action-btn:hover { background: #195084; }
    .wa-btn { background: #25D366; color: #fff; border: none; border-radius: 6px; font-size: 1em; font-weight: bold; padding: 7px 10px; margin-left: 6px; cursor: pointer; display: inline-flex; align-items: center; gap: 4px; }
    .wa-btn i { font-size: 1.1em; }
    .wa-btn:active { background: #189d44; }
    /* Full-width by default, but NOT for checkboxes/radios and NOT for custom dropdown option labels */
    #popup-content label:not(.dropdown-option):not(.exclude-total),
    #popup-content input:not([type="checkbox"]):not([type="radio"]),
    #popup-content .popup-btn-row {
  display: block !important;
  width: 100% !important;
  box-sizing: border-box !important;
}
#popup-content input:not([type="checkbox"]):not([type="radio"]) {
  margin-bottom: 13px !important;
}

/* Checkboxes inline with their text */
#popup-content input[type="checkbox"] {
  display: inline-block !important;
  width: auto !important;
  margin: 0 8px 0 0 !important;
}

/* Force dropdown option rows back to flex so checkbox is next to the name */
#popup-content .dropdown-list .dropdown-option {
  display: flex !important;
  align-items: center;
  gap: 10px;
}
#popup-content .dropdown-list .dropdown-option span {
  flex: 1 1 auto;
}
   .custom-dropdown {
  border: 1.4px solid #1467b7;
  border-radius: 7px;
  background: #f7fafd;
  margin-bottom: 15px;
  width: 100%;
  position: relative;
  font-size: 1.09em;
}

.dropdown-selected {
  padding: 13px 14px;
  cursor: pointer;
  user-select: none;
  border-radius: 7px;
}

.dropdown-list {
  position: absolute;
  top: 100%; left: 0; right: 0;
  background: #fff;
  border: 1.2px solid #1467b7;
  border-top: none;
  border-radius: 0 0 7px 7px;
  box-shadow: 0 8px 24px #1467b720;
  z-index: 9;
  max-height: 200px;
  overflow-y: auto;
}

.dropdown-option {
  padding: 13px 14px;
  cursor: pointer;
}

.dropdown-option:hover {
  background: #e3f2fd;
}

.dropdown-selected.disabled {
  color: #b6b6b6 !important;
  background: #f0f0f0 !important;
  pointer-events: none;
}
    .att-row {
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  border-bottom: 1px solid #f2f2f2;
  padding: 10px 0 4px 0;
}
.att-main {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 4px;
}
.att-name {
  font-weight: 600;
  color: #222;
  font-size: 1em;
  min-width: 110px;
  max-width: 170px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.att-badges {
  display: flex;
  gap: 10px;
  margin-top: 2px;
}
.att-badge {
  padding: 2px 13px;
  border-radius: 12px;
  font-weight: 600;
  font-size: 1em;
  display: inline-block;
  border: 1.3px solid #e0e0e0;
}
.att-m-present, .att-a-present { background: #eaf8ea; color: #208c2c; border: 1px solid #70d085;}
.att-m-absent,  .att-a-absent  { background: #fae9e9; color: #d43f3a; border: 1px solid #e48a8a;}
.att-total-box {
  border: 1.5px solid #1762a7;
  border-radius: 8px;
  padding: 5px 18px;
  min-width: 60px;
  font-size: 1.09em;
  background: #f8fcfe;
  text-align: center;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
}
.marks-row {
  display: flex;
  align-items: center;
  border-bottom: 1px solid #f3f3f3;
  padding: 10px 0;
  width: 100%;
}
.roll-name {
  flex: 1;
  min-width: 0;
  color: #1762a7;
  font-weight: 600;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  font-size: 1.08em;
}
.marks-input {
  width: 48px;
  max-width: 55px;
  font-size: 1.13em;
  padding: 4px 5px;
  border-radius: 7px;
  border: 1px solid #bbb;
  background: #f7fafd;
  text-align: right;
  margin-left: 10px;
}
    .call-icon:hover {
  color: #218c53 !important;
  text-decoration: none !important;
}
   /* Avatar shown in student list */
.avatar-img {
  width: 38px; height: 38px; border-radius: 50%;
  object-fit: cover; margin-right: 10px;
  box-shadow: 0 0 0 2px #e9f2fb;
}
.avatar-initials {
  width: 38px; height: 38px; border-radius: 50%;
  margin-right: 10px; background: #e7f1fb; color: #0f3d6b;
  display: inline-flex; align-items: center; justify-content: center;
  font-weight: 700;
}

/* Subject meta row (Subtopics mode + Exclude) */
.subject-meta-row{display:flex;align-items:center;gap:12px;flex-wrap:nowrap;justify-content:space-between;}
.subject-meta-row .subject-mode-dd{display:inline-flex!important;width:auto!important;min-width:160px;margin-bottom:0!important;border-color:#c7d7ea;background:#fff;}
.subject-meta-row .subject-mode-dd .dropdown-selected{padding:8px 10px;line-height:1.2;font-size:.97em;background:#fff;}
.subject-meta-row .subject-mode-dd .dropdown-list .dropdown-option{padding:8px 10px;}
#popup-content .subject-meta-row label{display:inline-flex!important;align-items:center;gap:8px;width:auto!important;margin:0!important;}
.subject-meta-row input[type="checkbox"]{margin:0;}
/* Photo UI inside Add/Edit popups */
.photo-row { display: flex; align-items: center; gap: 12px; margin-bottom: 10px; }
.photo-preview {
  width: 68px; height: 68px; border-radius: 50%;
  background: #e7f1fb; display:flex; align-items:center; justify-content:center;
  color:#0f3d6b; font-weight:700; overflow:hidden; box-shadow: 0 0 0 2px #e9f2fb;
}
.photo-preview img { width: 100%; height: 100%; object-fit: cover; display:block; }

.photo-actions { display: flex; flex-direction: column; gap: 6px; }
.photo-actions .mini { padding: 6px 10px; border-radius: 7px; border:none; font-weight:600; cursor:pointer; }
.photo-actions .mini.take { background:#1762a7; color:#fff; }
.photo-actions .mini.upload { background:#2ba84a; color:#fff; }
.photo-actions .mini.remove { background:#eee; color:#444; }

  </style>
</head>
<body>
  <div class="fixed-header" id="header">
  <div class="school-title" id="school-title"></div>
  <div class="subtitle" id="header-subtitle"></div>
  <div class="subtitle" id="header-exam" style="font-weight:600;"></div>
</div>
  <div class="main-content" id="main-area"></div>
  <button class="fab" id="fab"></button>
  <button class="settings-btn" id="settings-btn" title="Settings"><i class="fa fa-cog"></i></button>
  <div id="popup-bg"><div id="popup-content"></div></div>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-storage-compat.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
  <script>
    function normalizeExamName(name) {
   return name.replace(/[\s\.\-]/g, '').toUpperCase();
}
    // ======================= CONFIG ==============================
    const firebaseConfig = {
  apiKey: "AIzaSyBXCXAB2n2qqF6lIxpX5XYnqBWHClYik14",
  authDomain: "stpatricksprogresscard.firebaseapp.com",
  projectId: "stpatricksprogresscard",
  storageBucket: "stpatricksprogresscard.appspot.com",
  messagingSenderId: "671416933178",
  appId: "1:671416933178:web:4921d57abc6eb11bd2ce03"
};
     firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();
const auth = firebase.auth();

// CampusConnect custom alert (replaces window.alert)
(function setupCampusConnectAlert(){
  const dlgId = 'dlgAppAlert';
  if (document.getElementById(dlgId)) return;

  const wrapper = document.createElement('div');
  wrapper.innerHTML = `
    <dialog id="dlgAppAlert" style="border:none;border-radius:16px;padding:0;max-width:420px;width:92vw;">
      <div style="background:#0f3d6b;color:#fff;padding:10px 14px;border-radius:16px 16px 0 0;font-weight:600;font-size:15px;text-align:left;">
        CampusConnect
      </div>
      <div style="padding:14px 16px 10px 16px;font-size:14px;line-height:1.5;">
        <p id="appAlertText" style="margin:0 0 12px 0;"></p>
        <div style="text-align:right;margin-top:4px;">
          <button id="btnAppAlertOk"
                  style="background:#0f3d6b;color:#fff;border:none;border-radius:999px;padding:6px 16px;font-size:13px;font-weight:600;cursor:pointer;">
            OK
          </button>
        </div>
      </div>
    </dialog>
  `;
  const dialog = wrapper.firstElementChild;
  document.body.appendChild(dialog);

  const textEl = dialog.querySelector('#appAlertText');
  const okBtn  = dialog.querySelector('#btnAppAlertOk');

  function show(msg){
    if (textEl) textEl.textContent = msg;
    dialog.showModal();
  }

  if (okBtn) okBtn.onclick = () => dialog.close();

  // Override native alert
  window.alert = show;
})();
      const storage = firebase.storage();
      const CLASS_GROUP_MAP = {
  'Nursery': 'nursery-lkg-ukg',
  'LKG': 'nursery-lkg-ukg',
  'UKG': 'nursery-lkg-ukg',
  '1st Class': 'class-1-2',
  '2nd Class': 'class-1-2',
  '3rd Class': 'class-3-5',
  '4th Class': 'class-3-5',
  '5th Class': 'class-3-5',
  '6th Class': 'class-6-9',
  '7th Class': 'class-6-9',
  '8th Class': 'class-6-9',
  '9th Class': 'class-6-9',
  '10th Class': 'class-10'
};

function getClassGroupName(className) {
  return CLASS_GROUP_MAP[className] || 'default';
}
      function formatDate(dateStr) {
        // Converts "YYYY-MM-DD" to "DD-MM-YYYY"
        if (!dateStr) return '';
        const [year, month, day] = dateStr.split('-');
        return `${day}-${month}-${year}`;
      }
          // ======================= GLOBALS =============================

// NEW: resolve schoolId for multi-school scoping (Multipurpose School)
let schoolData = {};
try { schoolData = JSON.parse(localStorage.getItem('schoolData') || '{}'); } catch (e) {}
const schoolId = schoolData.schoolId;
if (!schoolId) {
  alert('School not set. Please sign in again.');
  window.location.replace('index.html');
}

// Set school header
const schoolTitleEl = document.getElementById('school-title');
const headerSubtitleEl = document.getElementById('header-subtitle');
if (schoolTitleEl) schoolTitleEl.textContent = schoolData.name || 'School Name';
if (headerSubtitleEl) headerSubtitleEl.textContent = schoolData.subtitle || 'CampusConnect';

// Dynamic document title per school
document.title = schoolData?.name
  ? `Students â€“ ${schoolData.name}`
  : 'Students â€“ CampusConnect';

let academicYear = localStorage.getItem('sp_selectedYear') || '';
console.log('academicYear raw:', academicYear, 'length:', academicYear.length);
document.getElementById('header-exam').textContent = academicYear;

// Persist current context for downstream pages (optional but matches section.html)
try {
  localStorage.setItem('sp_context', JSON.stringify({
    schoolId,
    year: academicYear,
    className: localStorage.getItem('sp_selectedClassName') || ''
  }));
} catch (e) {}

const mainArea = document.getElementById("main-area");
const popupBg = document.getElementById('popup-bg');
const popupContent = document.getElementById('popup-content');
const fab = document.getElementById('fab');
const settingsBtn = document.getElementById('settings-btn');
let currentClassId = localStorage.getItem('sp_selectedClassId') || '';
let currentClassName = localStorage.getItem('sp_selectedClassName') || '';
let currentSectionId = localStorage.getItem('sp_selectedSectionId') || '';
let currentSectionName = localStorage.getItem('sp_selectedSectionName') || '';

      
      // --- Only render UI after authentication ---
      let isAdmin = false;
    auth.onAuthStateChanged(function(user) {
      if (user) {
        isAdmin = (user.email === "messiah.sastry@stpatricksschool.com");
        fab.onclick = showAddStudentPopup;
        fab.style.display = "flex";
        settingsBtn.onclick = showSettingsPopup;
        settingsBtn.style.display = "flex";
        renderStudentList();
      } else {
        window.location.replace("index.html"); // redirect to login if not authenticated
      }
    });
  // === Photo helpers (square crop + resize + jpeg) ===
function getInitials(name='') {
  const parts = String(name).trim().split(/\s+/).filter(Boolean);
  const a = parts[0] ? parts[0][0] : '';
  const b = parts[1] ? parts[1][0] : '';
  return (a + b).toUpperCase() || 'S';
}

function dataURLToBlob(dataURL) {
  const arr = dataURL.split(','), mime = arr[0].match(/:(.*?);/)[1];
  const bstr = atob(arr[1]); let n = bstr.length; const u8arr = new Uint8Array(n);
  while (n--) u8arr[n] = bstr.charCodeAt(n);
  return new Blob([u8arr], { type: mime });
}

// Center-crop to square and resize to ~512px, compress to JPEG
function processImageFile(file, target=512, quality=0.85) {
  return new Promise((resolve, reject) => {
    const fr = new FileReader();
    fr.onload = () => {
      const img = new Image();
      img.onload = () => {
        const minSide = Math.min(img.width, img.height);
        const sx = Math.floor((img.width - minSide) / 2);
        const sy = Math.floor((img.height - minSide) / 2);
        const canvas = document.createElement('canvas');
        canvas.width = target; canvas.height = target;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, sx, sy, minSide, minSide, 0, 0, target, target);
        const dataUrl = canvas.toDataURL('image/jpeg', quality);
        const blob = dataURLToBlob(dataUrl);
        resolve({ blob, dataUrl });
      };
      img.onerror = reject;
      img.src = fr.result;
    };
    fr.onerror = reject;
    fr.readAsDataURL(file);
  });
}
    // ======================= MAIN LIST ===========================
    function renderStudentList() {
  if (!currentClassId || !currentSectionId) {
    mainArea.innerHTML = `<div style="color:#e74c3c; margin-top:40px;">Error: Class or Section not selected.</div>`;
    fab.style.display = "none";
    settingsBtn.style.display = "none";
    return;
  }

  db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
    .collection('classes').doc(currentClassId)
    .collection('sections').doc(currentSectionId)
    .collection('students')
    .orderBy('roll')
    .get()
    .then(snap => {
      let students = [];
      snap.forEach(doc => students.push({ id: doc.id, ...doc.data() }));

      let html = `<div class="screen-title">${currentClassName} â€“ ${currentSectionName}</div>
        <div class="student-list">`;

      if (students.length === 0) {
        html += `<div style="color:#888;font-style:italic;">No students found.</div>`;
      }

      students.filter(stu => !stu.isDeleted).forEach(stu => {
        const initials = getInitials(stu.name);
        const avatar = stu.photoUrl
          ? `<img class="avatar-img" src="${stu.photoUrl}" alt="${initials}">`
          : `<span class="avatar-initials">${initials}</span>`;

        html += `
          <div class="student-row" data-student-id="${stu.id}">
            ${avatar}
            <span class="roll-no">${stu.roll ? stu.roll + '.' : ''}</span>
            <span style="color:#1467b7; font-weight:600;">${stu.name}</span>
            <span style="flex:1"></span>
            ${
              stu.parentPhone
                ? `<a href="tel:${stu.parentPhone.replace(/\D/g, '')}" class="call-icon" title="Call Parent" style="margin-left:14px;color:#27ae60; font-size:1.17em;display:flex;align-items:center;justify-content:center;">
                     <i class="fa fa-phone"></i>
                   </a>`
                : `<i class="fa fa-phone" style="margin-left:14px;color:#bcbcbc;opacity:0.6; font-size:1.13em;" title="No phone number"></i>`
            }
          </div>`;
      });

      html += "</div>";
      mainArea.innerHTML = html;

      // long-press to open actions
      document.querySelectorAll('.student-row').forEach(row => {
        let pressTimer = null;
        row.addEventListener('mousedown', startPress);
        row.addEventListener('touchstart', startPress);
        row.addEventListener('mouseup', clearPress);
        row.addEventListener('mouseleave', clearPress);
        row.addEventListener('touchend', clearPress);

        function startPress() {
          pressTimer = setTimeout(() => {
            showStudentActionPopup(row.dataset.studentId);
          }, 600);
        }
        function clearPress() {
          clearTimeout(pressTimer);
        }
        // Desktop right-click support
row.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  showStudentActionPopup(row.dataset.studentId);
});
      });
    });
}
    // ===================== POPUP BASE ===========================
    function showPopup(htmlContent, formId = null, formSubmitHandler = null) {
      popupContent.innerHTML = htmlContent;
      popupBg.classList.add('show');
      popupBg.onclick = function(e) {
        if (e.target === popupBg) closePopup();
      };
      if (formId && formSubmitHandler) {
        const form = document.getElementById(formId);
        if (form) form.addEventListener('submit', formSubmitHandler);
      }
      popupContent.querySelectorAll('.popup-cancel-btn').forEach(btn => {
        btn.onclick = function(e) { e.preventDefault(); closePopup(); };
      });
    }
    function closePopup() {
      popupBg.classList.remove("show");
      popupContent.innerHTML = '';
      popupBg.onclick = null;
    }
    // ===== Download Status Helpers =====
function showDownloadStatus(text="Preparing download...") {
  const statusDiv = document.getElementById("downloadStatus");
  const spinner = document.getElementById("spinner");
  const statusText = document.getElementById("statusText");

  if (!statusDiv) return;
  statusDiv.style.display = "block";
  if (statusText) statusText.textContent = text;
  if (spinner) spinner.style.display = "block";
}

function markDownloadComplete(text="Download complete!") {
  const spinner = document.getElementById("spinner");
  const statusText = document.getElementById("statusText");

  if (spinner) spinner.style.display = "none";
  if (statusText) statusText.textContent = text;
}
  // ======================= CERTIFICATE GENERATOR =========================
function openCertificateGenerator(prefill = null) {
  // 1. Fetch all classes for this academic year
 db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
    .collection('classes').orderBy('name').get()
    .then(classSnap => {
      let classes = [];
      classSnap.forEach(doc => classes.push({ id: doc.id, ...doc.data() }));

      if (classes.length === 0) {
        showPopup(`
          <div class="popup-title">Generate Certificates</div>
          <div style="margin:16px 0;">No classes found! Please add students first.</div>
          <div class="popup-btn-row"><button class="popup-cancel-btn">Close</button></div>
        `);
        return;
      }

      let html = `
        <form id="certForm">
          <div class="popup-title">Generate Certificates (Top 3)</div>

          <label>Select Class</label>
          <div class="custom-dropdown" id="certClassDropdown">
            <div class="dropdown-selected" id="certClassSelected" data-value="">--Select--</div>
            <div class="dropdown-list" id="certClassList" style="display:none;"></div>
          </div>

          <label>Select Section</label>
          <div class="custom-dropdown" id="certSectionDropdown">
            <div class="dropdown-selected" id="certSectionSelected" data-value="">--Select Class First--</div>
            <div class="dropdown-list" id="certSectionList" style="display:none;"></div>
          </div>

          <label>Select Exam</label>
          <div class="custom-dropdown" id="certExamDropdown">
            <div class="dropdown-selected" id="certExamSelected" data-value="">--Select Section First--</div>
            <div class="dropdown-list" id="certExamList" style="display:none;"></div>
          </div>

          <div class="popup-btn-row" style="margin-top:10px;">
            <button type="button" class="popup-cancel-btn">Cancel</button>
            <button type="submit" class="popup-action-btn">Next</button>
          </div>
        </form>
      `;

      showPopup(html, 'certForm', function(e) {
        e.preventDefault();

        const classId = document.getElementById('certClassSelected').dataset.value;
        const className = document.getElementById('certClassSelected').textContent;
        const sectionId = document.getElementById('certSectionSelected').dataset.value;
        const sectionName = document.getElementById('certSectionSelected').textContent;
        const examId = document.getElementById('certExamSelected').dataset.value;
        const examName = document.getElementById('certExamSelected').textContent;

        if (!classId || !sectionId || !examId) {
          alert("Please select Class, Section, and Exam!");
          return;
        }

        closePopup();
        generateCertificatesForExam(classId, className, sectionId, sectionName, examId, examName);
      });
// helper function
function setupDropdown(dropdownId, selectedId, listId, onSelect) {
  const dropdown = document.getElementById(dropdownId);
  const selected = document.getElementById(selectedId);
  const list = document.getElementById(listId);
  if (!dropdown || !selected || !list) return;

  selected.onclick = () => {
    list.style.display = (list.style.display === "block" ? "none" : "block");
  };

  list.querySelectorAll(".dropdown-option").forEach(opt => {
    opt.onclick = () => {
      selected.textContent = opt.textContent;
      selected.dataset.value = opt.dataset.id || opt.dataset.value || "";
      list.style.display = "none";
      if (onSelect) onSelect(opt.dataset.id || opt.dataset.value, opt.textContent);
    };
  });

  document.addEventListener("click", function handler(e) {
    if (!dropdown.contains(e.target)) {
      list.style.display = "none";
      document.removeEventListener("click", handler);
    }
  });
}
      // Fill class dropdown
      const certClassList = document.getElementById('certClassList');
      certClassList.innerHTML = classes.map(c => `
        <div class="dropdown-option" data-id="${c.id}">${c.name}</div>
      `).join('');

      setupDropdown('certClassDropdown','certClassSelected','certClassList',(classId,className)=>{
  // fetch sections
  db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
    .collection('classes').doc(classId).collection('sections').orderBy('name').get()
    .then(secSnap=>{
      let secs=[];
      secSnap.forEach(d=>secs.push({id:d.id,...d.data()}));
      const certSectionList=document.getElementById('certSectionList');
      certSectionList.innerHTML=secs.map(s=>`
        <div class="dropdown-option" data-id="${s.id}">${s.name}</div>
      `).join('');
      const sectionSelected=document.getElementById('certSectionSelected');
      sectionSelected.textContent="--Select--";
      sectionSelected.dataset.value="";
      // ðŸ”‘ re-attach dropdown AFTER rebuilding list
      setupDropdown('certSectionDropdown','certSectionSelected','certSectionList',(sectionId,sectionName)=>{
        const classId=document.getElementById('certClassSelected').dataset.value;
        const className=document.getElementById('certClassSelected').textContent;
        const classGroup=getClassGroupName(className);
        fetchEffectiveExams(classId, className).then(exams=>{
  const certExamList=document.getElementById('certExamList');
  certExamList.innerHTML=(exams||[]).map(e=>`
    <div class="dropdown-option" data-id="${e.id}">${e.name}</div>
  `).join('');
  const examSelected=document.getElementById('certExamSelected');
  examSelected.textContent="--Select--";
  examSelected.dataset.value="";
  // re-attach exam dropdown as well
  setupDropdown('certExamDropdown','certExamSelected','certExamList');
  // ---- PREFILL (optional) ----
(async function prefillIfAny() {
  if (!prefill || !prefill.classId) return;

  // Prefill class
  const classSel = document.getElementById('certClassSelected');
  classSel.dataset.value = prefill.classId;
  classSel.textContent   = prefill.className || classSel.textContent;

  // Load sections for class
  const secSnap = await db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
    .collection('classes').doc(prefill.classId)
    .collection('sections').orderBy('name').get();

  const certSectionList = document.getElementById('certSectionList');
  certSectionList.innerHTML = secSnap.docs.map(d => `
    <div class="dropdown-option" data-id="${d.id}">${d.data().name}</div>
  `).join('');

  // Reset and attach section dropdown again
  const sectionSel = document.getElementById('certSectionSelected');
  sectionSel.textContent   = prefill.sectionName || '--Select--';
  sectionSel.dataset.value = prefill.sectionId   || '';
  setupDropdown('certSectionDropdown','certSectionSelected','certSectionList', async (sectionId, sectionName) => {
    const className = document.getElementById('certClassSelected').textContent;
    const classGroup = getClassGroupName(className);

    const examsEff = await fetchEffectiveExams(prefill.classId, className);
const certExamList = document.getElementById('certExamList');
certExamList.innerHTML = (examsEff||[]).map(e => `
  <div class="dropdown-option" data-id="${e.id}">${e.name}</div>
`).join('');

const examSel = document.getElementById('certExamSelected');
examSel.textContent   = '--Select--';
examSel.dataset.value = '';
setupDropdown('certExamDropdown','certExamSelected','certExamList');
  });

  // If we already know the section, load exams now and prefill exam too
  if (prefill.sectionId) {
  const className = classSel.textContent;
  const classId   = classSel.dataset.value;

  const exams = await fetchEffectiveExams(classId, className);
  const certExamList = document.getElementById('certExamList');
  certExamList.innerHTML = (exams || []).map(e => `
    <div class="dropdown-option" data-id="${e.id}">${e.name}</div>
  `).join('');

  const examSel = document.getElementById('certExamSelected');
  examSel.textContent   = prefill.examName || '--Select--';
  examSel.dataset.value = prefill.examId   || '';
  setupDropdown('certExamDropdown','certExamSelected','certExamList');
}
})();
      });
      });
    });
});
      setupDropdown('certSectionDropdown','certSectionSelected','certSectionList', (sectionId, sectionName) => {
  const classId  = document.getElementById('certClassSelected').dataset.value;
  const className = document.getElementById('certClassSelected').textContent;

  fetchEffectiveExams(classId, className).then((exams) => {
  const certExamList = document.getElementById('certExamList');
  const listHtml = (Array.isArray(exams) && exams.length)
    ? exams.map(e => `<div class="dropdown-option" data-id="${e.id}">${e.name}</div>`).join('')
    : `<div class="dropdown-option" data-id="" style="color:#888;">No exams for this class</div>`;
  certExamList.innerHTML = listHtml;

  const examSel = document.getElementById('certExamSelected');
  examSel.textContent = (Array.isArray(exams) && exams.length) ? "--Select--" : "No exams";
  examSel.dataset.value = (Array.isArray(exams) && exams.length) ? "" : "";
});
});

      setupDropdown('certExamDropdown','certExamSelected','certExamList');
    });
}

// ======================= ACTUAL CERTIFICATE GENERATION =========================

// helper: normalise subject keys (same as memos logic)
function nkey(name) {
  return (name || '')
    .toString()
    .trim()
    .toLowerCase()
    .replace(/\s+/g, ' ');
}

// helper: get EFFECTIVE exam structure (subjects + subtopics) for this class
async function getExamStructureForExamId(examId, classId, className) {
  try {
    const exams = await fetchEffectiveExams(classId, className);
    const found = (exams || []).find(e => e.id === examId);
    if (found) {
      return {
        subjects: Array.isArray(found.subjects) ? found.subjects : []
      };
    }
  } catch (e) {
    console.warn('getExamStructureForExamId failed:', e);
  }
  return { subjects: [] };
}

// helper: compute per-subject totals from marks + struct (same idea as memos/back page)
// RULE: if no numeric entries at all â†’ total === 'AB'.
//       If a number exists (including 0) â†’ sum the numbers.
function _extractSubjectTotalsFromMarks(marksObj, structure) {
  const subjects = [];
  const subsRoot = (marksObj && typeof marksObj.__subs === 'object') ? marksObj.__subs : {};

  const baseSubjects = (structure?.subjects?.length
    ? structure.subjects.map(s => s.name)
    : Object.keys(marksObj).filter(k =>
        !/^__subs(\b|[.\[])/i.test(k) && !/^__/.test(k)
      )
  );

  for (const subjName of baseSubjects) {
    // locate values for this subject
    const keyRoot = Object.keys(marksObj).find(k => nkey(k) === nkey(subjName));
    const subjVal = keyRoot ? marksObj[keyRoot] : marksObj[subjName];

    const keySubs = Object.keys(subsRoot || {}).find(k => nkey(k) === nkey(subjName));
    const subsObj = keySubs ? subsRoot[keySubs] : null;

    let total = 0;
    let max   = 0;
    let sawNumeric = false; // â† decisive flag

    // Prefer __subs breakdown
    if (subsObj && typeof subsObj === 'object') {
      for (const [k, v] of Object.entries(subsObj)) {
        if (typeof v === 'number' && !isNaN(v)) {      // includes 0
          total += +v;
          sawNumeric = true;
        }
        // infer max from exam structure if known
        const subjDef = structure?.subjects?.find(s => nkey(s.name) === nkey(subjName));
        const stDef   = subjDef?.subtopics?.find(t => nkey(t.name) === nkey(k));
        if (typeof stDef?.max === 'number') max += stDef.max;
      }
      // fallback subjectMax when we couldn't sum subtopic maxes
      if (max === 0) {
        const subjDef = structure?.subjects?.find(s => nkey(s.name) === nkey(subjName));
        if (typeof subjDef?.subjectMax === 'number') max = subjDef.subjectMax;
      }
    }
    // Or: object stored directly at the subject key
    else if (subjVal && typeof subjVal === 'object' && !Array.isArray(subjVal)) {
      for (const [, v] of Object.entries(subjVal)) {
        if (typeof v === 'number' && !isNaN(v)) {
          total += +v;
          sawNumeric = true;
        }
      }
      // no reliable max here
    }
    // Or: a scalar at the subject key
    else if (subjVal !== undefined) {
      if (typeof subjVal === 'number' && !isNaN(subjVal)) {
        total = +subjVal;      // 0 is valid
        sawNumeric = true;
      } else {
        // explicit AB / blank â†’ no numbers seen
        sawNumeric = false;
      }
      // try structure max
      const subjDef = structure?.subjects?.find(s => nkey(s.name) === nkey(subjName));
      if (typeof subjDef?.subjectMax === 'number') max = subjDef.subjectMax;
    }

    // Finalize per our rule
    const finalTotal = sawNumeric ? total : 'AB';

    // only include subjects that either have a number or are AB (skip truly missing subjects)
    if (sawNumeric || finalTotal === 'AB') {
      subjects.push({ name: subjName, total: finalTotal, max });
    }
  }

  return subjects;
}

async function generateCertificatesForExam(classId, className, sectionId, sectionName, examId, examName) {
  showPopup(`
    <div class="popup-title">Certificates: ${examName}</div>
    <div style="margin-bottom:12px;color:#555;">
      Certificates will be generated only for the <b>first three ranks</b> (including ties).
    </div>
    <div style="display:flex;flex-direction:column;gap:10px;">
  <button class="popup-action-btn" id="certOnePdfBtn">Generate One PDF (All Rankers)</button>
  <button class="popup-action-btn" id="certSeparateBtn">Generate Separate PDFs</button>
  <div style="display:flex; gap:10px; justify-content:center;">
    <button class="popup-action-btn" id="certBackBtn" style="flex:1; background:#eef3f8; color:#0f3d6b;">Back</button>
    <button class="popup-cancel-btn" style="flex:1;">Close</button>
  </div>
</div>
    <!-- Download status area -->
    <div id="downloadStatus" style="margin-top:15px; text-align:center; font-size:1.1em; color:#0f3d6b; display:none;">
      <div id="spinner" style="border: 4px solid #f3f3f3; border-top: 4px solid #0f3d6b; border-radius: 50%; width: 36px; height: 36px; animation: spin 1s linear infinite; margin: 0 auto 8px;"></div>
      <div id="statusText">Preparing download...</div>
    </div>

    <canvas id="certCanvas" width="2480" height="1754" style="display:none;"></canvas>

    <style>
    @keyframes spin { 
      0% { transform: rotate(0deg); } 
      100% { transform: rotate(360deg); } 
    }
    </style>
  `);

  const canvas = document.getElementById('certCanvas');
  const ctx = canvas.getContext('2d');

  // Assets
  const bgUrl = "https://raw.githubusercontent.com/MessiahSastry/Question-Bank/main/certificate.png";
  let bgImg = new Image();
  bgImg.crossOrigin = "anonymous";
  bgImg.src = bgUrl;

  // signatures removed
  const directorImg = null;
  const teacherImg  = null;
  
  // Rank badges
  const rank1Img = new Image(), rank2Img = new Image(), rank3Img = new Image();
  [rank1Img, rank2Img, rank3Img].forEach(i => (i.crossOrigin = "anonymous"));
  rank1Img.src = "https://raw.githubusercontent.com/MessiahSastry/Progress-card-app/main/rank-1.png";
  rank2Img.src = "https://raw.githubusercontent.com/MessiahSastry/Progress-card-app/main/rank-2.png";
  rank3Img.src = "https://raw.githubusercontent.com/MessiahSastry/Progress-card-app/main/rank-3.png";

  // Preload all assets once and reuse
  const decodeImg = (img) =>
    ("decode" in img)
      ? img.decode()
      : new Promise((res, rej) => { img.onload = res; img.onerror = rej; });
  const withTimeout = (p, ms) =>
    Promise.race([p, new Promise((_, rej) => setTimeout(() => rej(new Error("timeout")), ms))]);

  const assetsReady = Promise.allSettled([
    withTimeout(decodeImg(bgImg),    8000),
    withTimeout(decodeImg(rank1Img), 4000),
    withTimeout(decodeImg(rank2Img), 4000),
    withTimeout(decodeImg(rank3Img), 4000),
  ]); 
 
  // -- photo loader (with tiny cache) --
  const imgCache = new Map();
  async function loadPhoto(url) {
    if (!url) return null;
    if (imgCache.has(url)) return imgCache.get(url);
    try {
      const im = new Image();
      im.crossOrigin = "anonymous";
      im.referrerPolicy = "no-referrer";
      im.src = url;
      await withTimeout(decodeImg(im), 8000);
      imgCache.set(url, im);
      return im;
    } catch (e) {
      console.warn("Photo load failed:", e);
      imgCache.set(url, null);
      return null;
    }
  }

  function drawSquareImageCover(img, x, y, size) {
    const sw = img.naturalWidth || img.width;
    const sh = img.naturalHeight || img.height;
    const s  = Math.min(sw, sh);                 // center-crop to square
    const sx = Math.floor((sw - s) / 2);
    const sy = Math.floor((sh - s) / 2);

    ctx.drawImage(img, sx, sy, s, s, x, y, size, size);

    // optional border
    ctx.lineWidth = 8;
    ctx.strokeStyle = "#D4AF37";
    ctx.strokeRect(x, y, size, size);
  }

  function drawCircleImageCover(img, cx, cy, size) {
    const sw = img.naturalWidth || img.width;
    const sh = img.naturalHeight || img.height;
    const s  = Math.min(sw, sh);                 // center-crop to square
    const sx = Math.floor((sw - s) / 2);
    const sy = Math.floor((sh - s) / 2);
    const dx = cx - size / 2;
    const dy = cy - size / 2;

    // clip to circle and draw
    ctx.save();
    ctx.beginPath();
    ctx.arc(cx, cy, size / 2, 0, Math.PI * 2);
    ctx.clip();
    ctx.drawImage(img, sx, sy, s, s, dx, dy, size, size);
    ctx.restore();

    // border ring
    ctx.lineWidth = 8;
    ctx.strokeStyle = "#D4AF37";   
    ctx.beginPath();
    ctx.arc(cx, cy, size / 2, 0, Math.PI * 2);
    ctx.stroke();
  }

  // Prefer stu.photoUrl; if missing, resolve from Firebase Storage using photoPath
  async function resolveStudentPhoto(stu) {
    if (stu && stu.photoUrl) return stu.photoUrl;
    if (stu && stu.photoPath) {
      try {
        const url = await storage.ref().child(stu.photoPath).getDownloadURL();
        return url;
      } catch (e) {
        console.warn("getDownloadURL failed for", stu.photoPath, e);
      }
    }
    return null;
  }

  function drawCertificate(stu, rank, photoImg){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if (bgImg && bgImg.naturalWidth > 0) {
      ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
    } else {
      ctx.fillStyle = "#fff";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    ctx.fillStyle="#000"; ctx.textAlign="center";

    // Exam name
    ctx.font = "bold 64px 'Segoe UI'";
    ctx.fillText(examName,1211,600);

    // Student Name
    ctx.font = "72px 'Segoe Script'";
    ctx.fillStyle="#0f3d6b";
    ctx.fillText(stu.name,1223,800);

    // Class & Section
    ctx.font = "46px 'Segoe UI'";
    ctx.fillText(`(${className} / ${sectionName})`,1214,880);

    // Rank badge
    let rankImg = rank === 1 ? rank1Img : rank === 2 ? rank2Img : rank === 3 ? rank3Img : null;
    if (rankImg && rankImg.complete && rankImg.naturalWidth > 0) {
      const w = 300;
      const h = (rankImg.naturalHeight / rankImg.naturalWidth) * w;
      ctx.drawImage(rankImg, 1850, 600, w, h);
    }

    // --- Photo on left side (circle) ---
    const size = 360;
    const x    = 250;
    const y    = 540;
    const cx   = x + size / 2;
    const cy   = y + size / 2;

    if (photoImg && photoImg.complete && photoImg.naturalWidth > 0) {
      drawCircleImageCover(photoImg, cx, cy, size);
    } else {
      // circular fallback with initials
      ctx.save();
      ctx.beginPath();
      ctx.arc(cx, cy, size / 2, 0, Math.PI * 2);
      ctx.closePath();
      ctx.fillStyle = "#e7f1fb";
      ctx.fill();
      ctx.lineWidth = 8;
      ctx.strokeStyle = "#0f3d6b";
      ctx.stroke();

      const initials = getInitials(stu.name || '');
      ctx.fillStyle = "#0f3d6b";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.font = `bold ${Math.floor(size * 0.36)}px 'Segoe UI'`;
      ctx.fillText(initials, cx, cy + 2);
      ctx.restore();
    }
  }  

  async function generateCertificates(mode){
    const statusEl = document.getElementById("downloadStatus");
    const statusText = document.getElementById("statusText");
    const nextFrame = () => new Promise(r => requestAnimationFrame(() => r()));
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));

    // show spinner immediately
    statusEl.style.display = "block";
    statusText.textContent = "Preparing download...";

    // give the browser time to paint & start the CSS animation
    await nextFrame(); 
    await nextFrame();
    statusText.textContent = "Loading certificate assets...";
    await assetsReady;        // <-- ensures images are ready
    await nextFrame();
    try {
      // Fetch students
      const stuSnap = await db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
        .collection('classes').doc(classId)
        .collection('sections').doc(sectionId)
        .collection('students').orderBy('roll').get();

      let students=[];
      stuSnap.forEach(d=>{ 
        const x=d.data(); 
        if(!x.isDeleted) students.push({id:d.id,...x,cls:className,sec:sectionName}); 
      });

      // Fetch exam details
      const classGroup = getClassGroupName(className);
      const examDoc = await db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
        .collection('exams').doc('classGroups')
        .collection(classGroup).doc(examId).get();
      const exam = examDoc.exists ? examDoc.data() : { subjects: [] };

      // Robust structure for this exam (subjects + subtopics) â€“ EFFECTIVE exam
      const struct = await getExamStructureForExamId(examId, classId, className);

      // Build a set of subjects excluded from TOTAL (from the exam definition)
      const excludeSet = new Set(
        (exam.subjects || [])
          .filter(s => s && s.excludeFromTotal)
          .map(s => nkey(s.name))
      );

      for (const stu of students) {
        const mDoc = await db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
          .collection('classes').doc(classId)
          .collection('sections').doc(sectionId)
          .collection('students').doc(stu.id)
          .collection('marks').doc(examId).get();

        const marks = mDoc.exists ? (mDoc.data() || {}) : {};

        // Per-subject totals using the same helper as memos/back-page
        const subs = _extractSubjectTotalsFromMarks(marks, struct); // [{name,total,max}]
        const perMap = new Map();
        subs.forEach(s => {
          if (typeof s.total === 'number') {
            perMap.set(nkey(s.name), s.total);
          }
        });

        // Overall TOTAL = sum of numeric subject totals, skipping excluded subjects
        let totalMarks = 0;
        subs.forEach(s => {
          if (!excludeSet.size || !excludeSet.has(nkey(s.name))) {
            if (typeof s.total === 'number' && !isNaN(s.total)) {
              totalMarks += s.total;
            }
          }
        });

        stu.totalMarks = totalMarks;
        stu.__perSubjectTotals = perMap; // store for tie-break use
      }

                     // Helper: derive tie-break vector for a student
      // Uses the SAME normalized keys idea as memo ranking:
      // "math" OR ("math1" + "math2"), then physics, biology, chemistry.
      function buildTieVector(stu) {
        const map = stu.__perSubjectTotals || new Map();

        // map already uses nkey(name) as key; here we pass the keyNorm directly
        const get = (keyNorm) => {
          const v = map.get(keyNorm);
          return (typeof v === 'number' && !isNaN(v)) ? v : 0; // treat missing / AB as 0
        };

        const total = (typeof stu.totalMarks === 'number' && !isNaN(stu.totalMarks))
          ? stu.totalMarks
          : 0;

        // Single-paper Math (if present)
        const mathSingle = get('math');

        // Two-paper Math (Math1 + Math2)
        const m1 = get('math1');
        const m2 = get('math2');
        const mathFromPapers = m1 + m2;

        // Prefer single "Math" if present (>0), else use Math1 + Math2
        const mathTotal = (mathSingle > 0 ? mathSingle : mathFromPapers);

        const physics   = get('physics');
        const biology   = get('biology');
        const chemistry = get('chemistry');

        const rollNum = Number.isFinite(+stu.roll) ? +stu.roll : 999999;

        return {
          total,
          mathTotal,
          physics,
          biology,
          chemistry,
          roll: rollNum
        };
      }

                 // Rank by TOTAL with tie-break:
      // 1) TOTAL marks
      // 2) Math total (single "Math" OR "Math1 + Math2")
      // 3) Physics
      // 4) Biology
      // 5) Chemistry
      // 6) Lower roll number wins
      const ranked = [...students].sort((a, b) => {
        const A = buildTieVector(a);
        const B = buildTieVector(b);

        if (B.total     !== A.total)     return B.total     - A.total;
        if (B.mathTotal !== A.mathTotal) return B.mathTotal - A.mathTotal;
        if (B.physics   !== A.physics)   return B.physics   - A.physics;
        if (B.biology   !== A.biology)   return B.biology   - A.biology;
        if (B.chemistry !== A.chemistry) return B.chemistry - A.chemistry;

        // final fallback: lower roll number gets better rank
        return A.roll - B.roll;
      });

          // Ranking logic SAME as memos:
    // Only marks (Total + Math total + Phy + Bio + Chem) decide ties.
    // If all these are equal, students share the same rank,
    // even if their roll numbers differ.
    let lastVec = null;
    let rank = 1;

    ranked.forEach((d, i) => {
      const v = buildTieVector(d);  // { total, mathTotal, physics, biology, chemistry, roll }

      if (
        !lastVec ||
        v.total     !== lastVec.total ||
        v.mathTotal !== lastVec.mathTotal ||
        v.physics   !== lastVec.physics ||
        v.biology   !== lastVec.biology ||
        v.chemistry !== lastVec.chemistry
      ) {
        rank = i + 1;      // new rank whenever any mark differs
        lastVec = v;
      }

      d.rank = rank;
    });

      // Top 3 ranks (including ties)
      const top3 = ranked.filter(s => s.rank <= 3);
      if(top3.length===0){ alert("No students with ranks."); return; }

      const { PDFDocument } = PDFLib;
      const pdf=await PDFDocument.create();

      for (let i = 0; i < top3.length; i++) {
        const stu = top3[i];
        // ðŸ”¹ Progress update
        statusText.textContent = `Generating ${i+1} of ${top3.length}...`;
        await nextFrame();
    
        const url = await resolveStudentPhoto(stu);
        const photoImg = await loadPhoto(url);
        drawCertificate(stu, stu.rank, photoImg);
        const dataUrl=canvas.toDataURL("image/jpeg",0.95);
        const imgBytes=Uint8Array.from(atob(dataUrl.split(",")[1]),c=>c.charCodeAt(0));
        const jpg=await pdf.embedJpg(imgBytes);
        const page=pdf.addPage([842,595]);
        const s=Math.min(842/jpg.width,595/jpg.height);
        page.drawImage(jpg,{x:(842-jpg.width*s)/2,y:(595-jpg.height*s)/2,width:jpg.width*s,height:jpg.height*s});

        if (mode === "separate") {
          statusText.textContent = "Saving certificate...";
          await nextFrame();
          const one = await PDFDocument.create();
          const [p] = await one.copyPages(pdf, [pdf.getPageCount() - 1]);
          one.addPage(p);
          const bytes = await one.save();
          const a = document.createElement("a");
          a.href = URL.createObjectURL(new Blob([bytes], { type: "application/pdf" }));
          a.download = `Certificate_${stu.name}_${className}_${sectionName}_${examName}.pdf`;
          a.click();
        }
      }

      if (mode === "one") {
        statusText.textContent = "Generating all certificates...";
        await nextFrame();
        const bytes = await pdf.save();
        const a = document.createElement("a");
        a.href = URL.createObjectURL(new Blob([bytes], { type: "application/pdf" }));
        a.download = `Certificates_${className}_${sectionName}_${examName}.pdf`;
        a.click();

        statusText.textContent = "Download complete!";
        await sleep(1200);
      }

      // after the loop, if separate mode, show done message
      if (mode === "separate") {
        statusText.textContent = "All certificates saved!";
        await sleep(1200);
      }
    } catch (err) {
      console.error(err);
      statusText.textContent = "Something went wrong. Please try again.";
      await sleep(1200);
    } finally {
      statusEl.style.display = "none";
      statusText.textContent = "Preparing download...";
    }
  } 

  document.getElementById("certOnePdfBtn").onclick = () => generateCertificates("one");
  document.getElementById("certSeparateBtn").onclick = () => generateCertificates("separate");

  // NEW: Back button â†’ reopen the selector
  document.getElementById("certBackBtn").onclick = () => {
    closePopup();
    // reopen the selection popup (no prefill needed; works like a true â€œBackâ€)
    openCertificateGenerator();
  };
}
 // =========== ADD/EDIT STUDENT POPUP =========================
function showAddStudentPopup() {
  showPopup(`
    <form id="addStudentForm">
      <div class="popup-title">Add Student</div>

      <label>Student Name</label>
      <input name="studentName" maxlength="40" required>

      <label>Father's Name</label>
      <input name="fatherName" maxlength="40" required>
      <label>Child ID</label>
<input name="childId" maxlength="40" placeholder="e.g., SPT-9A-023">

      <label>Roll Number</label>
      <input name="rollNo" type="number" min="1" max="999" required>

      <label>Parent Phone Number</label>
      <input name="parentPhone" type="tel" maxlength="16" required placeholder="e.g., 9876543210">

      <label>Photo (optional)</label>
      <div class="photo-row">
        <div class="photo-preview" id="addPhotoPreview">${getInitials('')}</div>
        <div class="photo-actions">
          <button type="button" class="mini take" id="btnTakePhoto">Take photo</button>
          <button type="button" class="mini upload" id="btnUploadPhoto">Upload photo</button>
          <button type="button" class="mini remove" id="btnRemovePhoto" style="display:none;">Remove photo</button>

          <!-- hidden inputs for camera / file -->
          <input type="file" id="inputCamera" accept="image/*" capture="environment" style="display:none;" />
          <input type="file" id="inputFile" accept="image/*" style="display:none;" />
        </div>
      </div>

      <!-- ======= Circular Cropper Modal (hidden by default) ======= -->
      <div id="addCropperOverlay" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.6);z-index:9999;">
        <div style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:min(92vw,520px);background:#fff;border-radius:16px;box-shadow:0 10px 40px rgba(0,0,0,.25);">
          <div style="padding:14px 16px;border-bottom:1px solid #eee;font-weight:700;color:#0f3d6b;">Crop your photo</div>
          <div style="padding:12px 12px 4px 12px;">
            <div id="addCropBox" style="position:relative;width:100%;border-radius:12px;background:#111;overflow:hidden;touch-action:none;">
              <canvas id="addCropCanvas" style="width:100%;height:100%;display:block;"></canvas>
              </div>
            <div style="display:flex;gap:8px;justify-content:center;margin-top:10px;flex-wrap:wrap;">
              <button type="button" class="mini" id="addZoomOut">âˆ’</button>
              <button type="button" class="mini" id="addZoomIn">+</button>
              <button type="button" class="mini" id="addReset">Reset</button>
            </div>
          </div>
          <div style="display:flex;gap:10px;justify-content:flex-end;padding:12px;border-top:1px solid #eee;">
            <button type="button" class="popup-cancel-btn" id="addCropCancel">Cancel</button>
            <button type="button" class="popup-action-btn" id="addCropUse">Use Photo</button>
          </div>
        </div>
      </div>
      <!-- ======= /Circular Cropper Modal ======= -->

      <div class="popup-btn-row">
        <button type="button" class="popup-cancel-btn">Cancel</button>
        <button type="submit" class="popup-action-btn">Add</button>
      </div>
    </form>
  `, 'addStudentForm', async function (e) {
    e.preventDefault();

    const name = e.target.studentName.value.trim();
    const father = e.target.fatherName.value.trim();
    const childId = (e.target.childId?.value || '').trim();
    const roll = parseInt(e.target.rollNo.value.trim(), 10);
    const parentPhone = e.target.parentPhone.value.replace(/\D/g, '');
    if (!name || !father || isNaN(roll) || parentPhone.length < 10 || parentPhone.length > 12) {
      alert('Please enter a 10â€“12 digit parent phone number (digits only).');
      return;
    }

    // 1) Create the student first (without photo)
    const docRef = await db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
      .collection('classes').doc(currentClassId)
      .collection('sections').doc(currentSectionId)
      .collection('students').add({ name, father, roll, parentPhone, childId });

    // 2) If a photo is selected, upload to Storage and save URL in Firestore
    if (window.__addPhotoBlob) {
      try {
        const path = `years/${academicYear}/classes/${currentClassId}/sections/${currentSectionId}/students/${docRef.id}/profile.jpg`;
        const ref = storage.ref().child(path);

        await ref.put(window.__addPhotoBlob, {
          contentType: 'image/jpeg',
          cacheControl: 'public,max-age=31536000'
        });

        const url = await ref.getDownloadURL();
        await docRef.update({ photoUrl: url, photoPath: path });
      } catch (err) {
        console.error('Photo upload failed:', err);
        alert('Student saved, but photo upload failed.');
      }
    }
    closePopup();
    renderStudentList();
  });

  // --- Photo controls (scoped to this popup) ---
  window.__addPhotoBlob = null;
  const prev   = document.getElementById('addPhotoPreview');
  const btnCam = document.getElementById('btnTakePhoto');
  const btnUp  = document.getElementById('btnUploadPhoto');
  const btnRem = document.getElementById('btnRemovePhoto');
  const inputCam  = document.getElementById('inputCamera');
  const inputFile = document.getElementById('inputFile');

  function showPreviewFromDataUrl(dataUrl){
    prev.innerHTML = '';
    const img = document.createElement('img');
    img.src = dataUrl;
    prev.appendChild(img);
    btnRem.style.display = 'inline-block';
  }

  // === CROPPER STATE ===
  let addCrop = {
    img: null, imgW: 0, imgH: 0,
    canvas: null, ctx: null,
    scale: 1, minScale: 1, maxScale: 10,
    offX: 0, offY: 0,
    startX: 0, startY: 0, dragging: false
  };

  function openAddCropper(file) {
    const overlay = document.getElementById('addCropperOverlay');
    const canvas  = document.getElementById('addCropCanvas');
    const ctx     = canvas.getContext('2d');
    addCrop.canvas = canvas;
    addCrop.ctx    = ctx;

    // --- Force a true square in CSS and scale backing store for DPR ---
    const boxEl   = document.getElementById('addCropBox');
    const cssSize = Math.floor(boxEl.clientWidth); // CSS px
    boxEl.style.height = cssSize + 'px';           // square
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.style.width  = cssSize + 'px';
    canvas.style.height = cssSize + 'px';
    canvas.width  = Math.floor(cssSize * dpr);
    canvas.height = Math.floor(cssSize * dpr);

    const img = new Image();
    img.onload = () => {
      addCrop.img  = img;
      addCrop.imgW = img.naturalWidth;
      addCrop.imgH = img.naturalHeight;

         // Cover-fit the full square canvas (device px)
    const needW = canvas.width;
    const needH = canvas.height;
    const scaleX = needW / img.naturalWidth;
    const scaleY = needH / img.naturalHeight;
    addCrop.minScale = Math.max(scaleX, scaleY);
    addCrop.scale    = Math.max(addCrop.minScale, 1);
    addCrop.maxScale = Math.max(addCrop.scale * 8, 8);

      // DPR + center offsets (device px)
      addCrop.dpr  = dpr;
      addCrop.offX = canvas.width / 2;
      addCrop.offY = canvas.height / 2;

      drawAddCropper();
    };
    img.onerror = () => alert('Could not load image.');
    img.src = URL.createObjectURL(file);

    // ---- Pointer/gesture events (drag + pinch) ----
const addTouches = new Map();
let addLastDist = null;

canvas.onpointerdown = (e) => {
  canvas.setPointerCapture(e.pointerId);
  addTouches.set(e.pointerId, { x: e.clientX, y: e.clientY });
  if (addTouches.size === 1) {
    addCrop.dragging = true;
    addCrop.startX = e.clientX;
    addCrop.startY = e.clientY;
  } else if (addTouches.size === 2) {
    addCrop.dragging = false;
    const pts = Array.from(addTouches.values());
    const dx = pts[1].x - pts[0].x;
    const dy = pts[1].y - pts[0].y;
    addLastDist = Math.hypot(dx, dy);
  }
};

canvas.onpointermove = (e) => {
  if (!addTouches.has(e.pointerId)) return;
  addTouches.set(e.pointerId, { x: e.clientX, y: e.clientY });

  const d = addCrop.dpr || 1;

  if (addTouches.size === 2) {
    // Pinch zoom around midpoint
    const pts = Array.from(addTouches.values());
    const midXcss = (pts[0].x + pts[1].x) / 2;
    const midYcss = (pts[0].y + pts[1].y) / 2;
    const rect = canvas.getBoundingClientRect();
    const midX = (midXcss - rect.left) * d; // device px
    const midY = (midYcss - rect.top)  * d;

    const dx = pts[1].x - pts[0].x;
    const dy = pts[1].y - pts[0].y;
    const dist = Math.hypot(dx, dy);
    if (addLastDist) {
      const factor = dist / addLastDist;
      const prev = addCrop.scale;
      let next = prev * factor;
      next = Math.min(Math.max(next, addCrop.minScale), addCrop.maxScale);
      const k = next / prev;
      // zoom about midpoint
      addCrop.offX = midX - (midX - addCrop.offX) * k;
      addCrop.offY = midY - (midY - addCrop.offY) * k;
      addCrop.scale = next;
      drawAddCropper();
    }
    addLastDist = dist;
    return;
  }

  if (addCrop.dragging) {
    const dxCss = e.clientX - addCrop.startX;
    const dyCss = e.clientY - addCrop.startY;
    addCrop.startX = e.clientX;
    addCrop.startY = e.clientY;
    addCrop.offX += dxCss * d;
    addCrop.offY += dyCss * d;
    drawAddCropper();
  }
};

canvas.onpointerup = (e) => {
  addTouches.delete(e.pointerId);
  canvas.releasePointerCapture(e.pointerId);
  if (addTouches.size < 2) addLastDist = null;
  if (addTouches.size === 0) addCrop.dragging = false;
};

    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const delta = e.deltaY < 0 ? 1.06 : 0.94;
      const prevScale = addCrop.scale;
      let next = prevScale * delta;
      next = Math.min(Math.max(next, addCrop.minScale), addCrop.maxScale);

      const rect = canvas.getBoundingClientRect();
      const d = addCrop.dpr || 1;
      const cx = (e.clientX - rect.left) * d;
      const cy = (e.clientY - rect.top)  * d;
      const k = next / prevScale;
      addCrop.offX = cx - (cx - addCrop.offX) * k;
      addCrop.offY = cy - (cy - addCrop.offY) * k;

      addCrop.scale = next;
      drawAddCropper();
    }, { passive: false });

    document.getElementById('addZoomIn').onclick = () => {
      addCrop.scale = Math.min(addCrop.scale * 1.1, addCrop.maxScale);
      drawAddCropper();
    };
    document.getElementById('addZoomOut').onclick = () => {
      addCrop.scale = Math.max(addCrop.scale / 1.1, addCrop.minScale);
      drawAddCropper();
    };
    document.getElementById('addReset').onclick = () => {
      addCrop.scale = Math.max(addCrop.minScale, 1);
      addCrop.offX = canvas.width / 2;
      addCrop.offY = canvas.height / 2;
      drawAddCropper();
    };
    document.getElementById('addCropCancel').onclick = () => {
      overlay.style.display = 'none';
    };
    document.getElementById('addCropUse').onclick = async () => {
      const outSize = 512;
      const out = document.createElement('canvas');
      out.width = outSize; out.height = outSize;
      const octx = out.getContext('2d');
      octx.fillStyle = '#ffffff';
      octx.fillRect(0,0,outSize,outSize);

         // Square export (no clipping)
      octx.save();

      // Map preview transform (device px) directly to output
      const k = outSize / canvas.width; // device px â†’ output px
      octx.setTransform(addCrop.scale * k, 0, 0, addCrop.scale * k, addCrop.offX * k, addCrop.offY * k);
      octx.drawImage(addCrop.img, -addCrop.imgW / 2, -addCrop.imgH / 2);
      octx.restore();

      const dataUrl = out.toDataURL('image/jpeg', 0.85);
      const blob = await (await fetch(dataUrl)).blob();

      window.__addPhotoBlob = blob;
      showPreviewFromDataUrl(dataUrl);

      document.getElementById('addCropperOverlay').style.display = 'none';
    };
  }

  function drawAddCropper() {
    const { ctx, canvas, img, imgW, imgH, scale, offX, offY } = addCrop;
    if (!img) return;
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#111';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // All offsets are in DEVICE px
    ctx.setTransform(scale, 0, 0, scale, offX, offY);
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.drawImage(img, -imgW/2, -imgH/2);
  }

  async function handleAddFile(file){
    if (!file) return;
    openAddCropper(file);
  }

  btnCam.onclick       = () => inputCam.click();
  btnUp.onclick        = () => inputFile.click();
  inputCam.onchange    = (e) => handleAddFile(e.target.files && e.target.files[0]);
  inputFile.onchange   = (e) => handleAddFile(e.target.files && e.target.files[0]);
  btnRem.onclick       = () => {
    window.__addPhotoBlob = null;
    prev.textContent = getInitials('');
    btnRem.style.display = 'none';
  };
}

// --- EDIT Student (with optional photo update/remove) ---
async function showEditStudentPopup(studentId) {
  const docRef = db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
    .collection('classes').doc(currentClassId)
    .collection('sections').doc(currentSectionId)
    .collection('students').doc(studentId);

  const snap = await docRef.get();
  if (!snap.exists) { alert('Student not found'); return; }
  const stu = snap.data() || {};

  showPopup(`
    <form id="editStudentForm">
      <div class="popup-title">Edit Student</div>

      <label>Student Name</label>
      <input name="studentName" maxlength="40" required value="${stu.name || ''}">

      <label>Father's Name</label>
      <input name="fatherName" maxlength="40" required value="${stu.father || ''}">
      <label>Child ID</label>
      <input name="childId" maxlength="40" placeholder="e.g., SPT-9A-023" value="${stu.childId || ''}">
      <label>Roll Number</label>
      <input name="rollNo" type="number" min="1" max="999" required value="${stu.roll || ''}">

      <label>Parent Phone Number</label>
      <input name="parentPhone" type="tel" maxlength="16" required placeholder="e.g., 9876543210" value="${stu.parentPhone || ''}">

      <label>Photo (optional)</label>
      <div class="photo-row">
        <div class="photo-preview" id="editPhotoPreview">${stu.photoUrl ? '' : getInitials(stu.name || '')}</div>
        <div class="photo-actions">
          <button type="button" class="mini take" id="btnEditTakePhoto">Take photo</button>
          <button type="button" class="mini upload" id="btnEditUploadPhoto">Upload photo</button>
          <button type="button" class="mini remove" id="btnEditRemovePhoto" style="${stu.photoUrl ? '' : 'display:none;'}">${stu.photoUrl ? 'Remove current photo' : 'Remove photo'}</button>

          <!-- hidden inputs for camera / file -->
          <input type="file" id="inputEditCamera" accept="image/*" capture="environment" style="display:none;" />
          <input type="file" id="inputEditFile" accept="image/*" style="display:none;" />
        </div>
      </div>

      <!-- ======= Circular Cropper Modal (hidden by default) ======= -->
      <div id="editCropperOverlay" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.6);z-index:9999;">
        <div style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:min(92vw,520px);background:#fff;border-radius:16px;box-shadow:0 10px 40px rgba(0,0,0,.25);">
          <div style="padding:14px 16px;border-bottom:1px solid #eee;font-weight:700;color:#0f3d6b;">Crop your photo</div>
          <div style="padding:12px 12px 4px 12px;">
            <div id="editCropBox" style="position:relative;width:100%;border-radius:12px;background:#111;overflow:hidden;touch-action:none;">
              <canvas id="editCropCanvas" style="width:100%;height:100%;display:block;"></canvas>
              </div>
            <div style="display:flex;gap:8px;justify-content:center;margin-top:10px;flex-wrap:wrap;">
              <button type="button" class="mini" id="editZoomOut">âˆ’</button>
              <button type="button" class="mini" id="editZoomIn">+</button>
              <button type="button" class="mini" id="editReset">Reset</button>
            </div>
          </div>
          <div style="display:flex;gap:10px;justify-content:flex-end;padding:12px;border-top:1px solid #eee;">
            <button type="button" class="popup-cancel-btn" id="editCropCancel">Cancel</button>
            <button type="button" class="popup-action-btn" id="editCropUse">Use Photo</button>
          </div>
        </div>
      </div>
      <!-- ======= /Circular Cropper Modal ======= -->

      <div class="popup-btn-row">
        <button type="button" class="popup-cancel-btn">Cancel</button>
        <button type="submit" class="popup-action-btn">Save</button>
      </div>
    </form>
  `, 'editStudentForm', async function (e) {
    e.preventDefault();

    const name = e.target.studentName.value.trim();
    const father = e.target.fatherName.value.trim();
    const childId = (e.target.childId?.value || '').trim();
    const roll = parseInt(e.target.rollNo.value.trim(), 10);
    const parentPhone = e.target.parentPhone.value.replace(/\D/g, '');
    if (!name || !father || isNaN(roll) || parentPhone.length < 10 || parentPhone.length > 12) {
      alert('Please enter a 10â€“12 digit parent phone number (digits only).');
      return;
    }

    try {
      await docRef.update({ name, father, roll, parentPhone, childId });
    } catch (err) {
      console.error(err);
      alert('Failed to save. ' + (err && err.message ? err.message : ''));
      return;
    }

    // If user chose to REMOVE photo (and did not upload a new one)
    if (window.__editRemovePhoto === true && !window.__editPhotoBlob) {
      try {
        if (stu.photoPath) {
          await storage.ref().child(stu.photoPath).delete().catch(() => {});
        }
        await docRef.update({
          photoUrl: firebase.firestore.FieldValue.delete(),
          photoPath: firebase.firestore.FieldValue.delete()
        });
      } catch (err) {
        console.error('Remove photo failed:', err);
        alert('Details saved, but photo removal failed.');
      }
    }

    // If user uploaded/took a new photo
    if (window.__editPhotoBlob) {
      try {
        const path = `years/${academicYear}/classes/${currentClassId}/sections/${currentSectionId}/students/${studentId}/profile.jpg`;
        const sref = storage.ref().child(path);

        await sref.put(window.__editPhotoBlob, {
          contentType: 'image/jpeg',
          cacheControl: 'public,max-age=31536000'
        });

        const url = await sref.getDownloadURL();
        await docRef.update({ photoUrl: url, photoPath: path });
      } catch (err) {
        console.error('Edit photo error:', err);
        alert('Details updated, but photo change failed. You can try again.');
      }
    }

    closePopup();
    renderStudentList();
  });

  // --- Photo controls (scoped to this popup) ---
  window.__editPhotoBlob = null;
  window.__editRemovePhoto = false;

  const prevE    = document.getElementById('editPhotoPreview');
  const btnCamE  = document.getElementById('btnEditTakePhoto');
  const btnUpE   = document.getElementById('btnEditUploadPhoto');
  const btnRemE  = document.getElementById('btnEditRemovePhoto');
  const inputCamE  = document.getElementById('inputEditCamera');
  const inputFileE = document.getElementById('inputEditFile');

  function showPreviewFromUrl(url) {
    prevE.innerHTML = '';
    const img = document.createElement('img');
    img.src = url;
    prevE.appendChild(img);
  }
  function showPreviewFromDataUrlE(dataUrl) {
    prevE.innerHTML = '';
    const img = document.createElement('img');
    img.src = dataUrl;
    prevE.appendChild(img);
  }
  function showInitials() {
    prevE.textContent = getInitials(stu.name || '');
  }
  if (stu.photoUrl) { showPreviewFromUrl(stu.photoUrl); }

  // === CROPPER STATE ===
  let editCrop = {
    img: null, imgW: 0, imgH: 0,
    canvas: null, ctx: null,
    scale: 1, minScale: 1, maxScale: 10,
    offX: 0, offY: 0,
    startX: 0, startY: 0, dragging: false
  };

  function openEditCropper(file) {
    const overlay = document.getElementById('editCropperOverlay');
    const canvas  = document.getElementById('editCropCanvas');
    const ctx     = canvas.getContext('2d');
    editCrop.canvas = canvas;
    editCrop.ctx    = ctx;

    // --- Show overlay first so measurements are non-zero ---
    overlay.style.display = 'block';

    // --- Force a true square in CSS and scale backing store for DPR ---
    const boxEl   = document.getElementById('editCropBox');
    const cssSize = Math.max(240, Math.floor((boxEl.clientWidth || overlay.clientWidth)));
    boxEl.style.height = cssSize + 'px';
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.style.width  = cssSize + 'px';
    canvas.style.height = cssSize + 'px';
    canvas.width  = Math.floor(cssSize * dpr);
    canvas.height = Math.floor(cssSize * dpr);

    const img = new Image();
    img.onload = () => {
      editCrop.img  = img;
      editCrop.imgW = img.naturalWidth;
      editCrop.imgH = img.naturalHeight;

          const needW = canvas.width;
          const needH = canvas.height;
          const scaleX = needW / img.naturalWidth;
          const scaleY = needH / img.naturalHeight;
          editCrop.minScale = Math.max(scaleX, scaleY);
          editCrop.scale    = Math.max(editCrop.minScale, 1);
          editCrop.maxScale = Math.max(editCrop.scale * 8, 8);

      editCrop.dpr  = dpr;
      editCrop.offX = canvas.width / 2;
      editCrop.offY = canvas.height / 2;

      drawEditCropper();
    };
    img.onerror = () => alert('Could not load image.');
    img.src = URL.createObjectURL(file);

    // Drag + pinch
const editTouches = new Map();
let editLastDist = null;

canvas.onpointerdown = (e) => {
  canvas.setPointerCapture(e.pointerId);
  editTouches.set(e.pointerId, { x: e.clientX, y: e.clientY });
  if (editTouches.size === 1) {
    editCrop.dragging = true;
    editCrop.startX = e.clientX;
    editCrop.startY = e.clientY;
  } else if (editTouches.size === 2) {
    editCrop.dragging = false;
    const pts = Array.from(editTouches.values());
    const dx = pts[1].x - pts[0].x;
    const dy = pts[1].y - pts[0].y;
    editLastDist = Math.hypot(dx, dy);
  }
};

canvas.onpointermove = (e) => {
  if (!editTouches.has(e.pointerId)) return;
  editTouches.set(e.pointerId, { x: e.clientX, y: e.clientY });

  const d = editCrop.dpr || 1;

  if (editTouches.size === 2) {
    const pts = Array.from(editTouches.values());
    const midXcss = (pts[0].x + pts[1].x) / 2;
    const midYcss = (pts[0].y + pts[1].y) / 2;
    const rect = canvas.getBoundingClientRect();
    const midX = (midXcss - rect.left) * d;
    const midY = (midYcss - rect.top)  * d;

    const dx = pts[1].x - pts[0].x;
    const dy = pts[1].y - pts[0].y;
    const dist = Math.hypot(dx, dy);
    if (editLastDist) {
      const factor = dist / editLastDist;
      const prev = editCrop.scale;
      let next = prev * factor;
      next = Math.min(Math.max(next, editCrop.minScale), editCrop.maxScale);
      const k = next / prev;
      editCrop.offX = midX - (midX - editCrop.offX) * k;
      editCrop.offY = midY - (midY - editCrop.offY) * k;
      editCrop.scale = next;
      drawEditCropper();
    }
    editLastDist = dist;
    return;
  }

  if (editCrop.dragging) {
    const dxCss = e.clientX - editCrop.startX;
    const dyCss = e.clientY - editCrop.startY;
    editCrop.startX = e.clientX;
    editCrop.startY = e.clientY;
    editCrop.offX += dxCss * d;
    editCrop.offY += dyCss * d;
    drawEditCropper();
  }
};

canvas.onpointerup = (e) => {
  editTouches.delete(e.pointerId);
  canvas.releasePointerCapture(e.pointerId);
  if (editTouches.size < 2) editLastDist = null;
  if (editTouches.size === 0) editCrop.dragging = false;
};
    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const delta = e.deltaY < 0 ? 1.06 : 0.94;
      const prevScale = editCrop.scale;
      let next = prevScale * delta;
      next = Math.min(Math.max(next, editCrop.minScale), editCrop.maxScale);

      const rect = canvas.getBoundingClientRect();
      const d = editCrop.dpr || 1;
      const cx = (e.clientX - rect.left) * d;
      const cy = (e.clientY - rect.top)  * d;
      const k = next / prevScale;
      editCrop.offX = cx - (cx - editCrop.offX) * k;
      editCrop.offY = cy - (cy - editCrop.offY) * k;

      editCrop.scale = next;
      drawEditCropper();
    }, { passive: false });

    document.getElementById('editZoomIn').onclick = () => {
      editCrop.scale = Math.min(editCrop.scale * 1.1, editCrop.maxScale);
      drawEditCropper();
    };
    document.getElementById('editZoomOut').onclick = () => {
      editCrop.scale = Math.max(editCrop.scale / 1.1, editCrop.minScale);
      drawEditCropper();
    };
    document.getElementById('editReset').onclick = () => {
      editCrop.scale = Math.max(editCrop.minScale, 1);
      editCrop.offX = canvas.width / 2;
      editCrop.offY = canvas.height / 2;
      drawEditCropper();
    };
    document.getElementById('editCropCancel').onclick = () => {
      overlay.style.display = 'none';
    };
    document.getElementById('editCropUse').onclick = async () => {
      const outSize = 512;
      const out = document.createElement('canvas');
      out.width = outSize; out.height = outSize;
      const octx = out.getContext('2d');
      octx.fillStyle = '#ffffff';
      octx.fillRect(0,0,outSize,outSize);

          // Square export (no clipping)
        octx.save();
      const k = outSize / canvas.width; // device px â†’ output px
      octx.setTransform(editCrop.scale * k, 0, 0, editCrop.scale * k, editCrop.offX * k, editCrop.offY * k);
      octx.drawImage(editCrop.img, -editCrop.imgW / 2, -editCrop.imgH / 2);
      octx.restore();


      const dataUrl = out.toDataURL('image/jpeg', 0.85);
      const blob = await (await fetch(dataUrl)).blob();

      window.__editPhotoBlob = blob;
      window.__editRemovePhoto = false;
      showPreviewFromDataUrlE(dataUrl);
      if (btnRemE) btnRemE.style.display = 'inline-block';

      document.getElementById('editCropperOverlay').style.display = 'none';
    };
  }

  function drawEditCropper() {
    const { ctx, canvas, img, imgW, imgH, scale, offX, offY } = editCrop;
    if (!img) return;
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#111';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.setTransform(scale, 0, 0, scale, offX, offY);
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.drawImage(img, -imgW/2, -imgH/2);
  }

  async function handleEditFile(file) {
    if (!file) return;
    openEditCropper(file);
  }

  btnCamE.onclick      = () => inputCamE.click();
  btnUpE.onclick       = () => inputFileE.click();
  inputCamE.onchange   = (e) => handleEditFile(e.target.files && e.target.files[0]);
  inputFileE.onchange  = (e) => handleEditFile(e.target.files && e.target.files[0]);
  if (btnRemE) {
    btnRemE.onclick = () => {
      window.__editPhotoBlob = null;
      window.__editRemovePhoto = true;
      showInitials();
      btnRemE.style.display = 'none';
    };
  }
}

// ---- Student action popup (Edit / Delete) ----
function showStudentActionPopup(studentId) {
  (async () => {
    // Load the student to show context in the action sheet
    const ref = db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
      .collection('classes').doc(currentClassId)
      .collection('sections').doc(currentSectionId)
      .collection('students').doc(studentId);

    const snap = await ref.get();
    if (!snap.exists) {
      alert("Student not found.");
      return;
    }
    const stu = snap.data() || {};
    const initials = getInitials(stu.name || '');
    const avatar = stu.photoUrl
      ? `<img class="avatar-img" src="${stu.photoUrl}" alt="${initials}">`
      : `<span class="avatar-initials">${initials}</span>`;

    showPopup(`
      <div class="popup-title">Student Options</div>

      <div style="display:flex;align-items:center;gap:10px;margin-bottom:8px;">
        ${avatar}
        <div style="min-width:0;">
          <div style="font-weight:700;color:#0f3d6b;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">
            ${stu.roll ? (stu.roll + '. ') : ''}${stu.name || ''}
          </div>
          <div style="color:#777;font-size:.95em;">
            Father: ${stu.father || '-'}
          </div>
        </div>
      </div>

      <div style="display:flex;flex-direction:column;gap:10px;">
        <button type="button" class="popup-action-btn" id="actEdit">Edit Student</button>
        <button type="button" class="popup-action-btn" id="actDelete" style="background:#d43f3a;">Delete Student</button>
      </div>

      <div class="popup-btn-row" style="margin-top:10px;">
        <button type="button" class="popup-cancel-btn">Close</button>
      </div>
    `);

    // Wire actions
    setTimeout(() => {
      const editBtn = popupContent.querySelector('#actEdit');
      const delBtn  = popupContent.querySelector('#actDelete');

      if (editBtn) editBtn.onclick = () => {
        closePopup();
        showEditStudentPopup(studentId);
      };

      if (delBtn) delBtn.onclick = async () => {
        if (!confirm("Delete this student? You can restore later from Settings â†’ Show Deleted Students.")) return;
        try {
          await ref.update({ isDeleted: true });
          closePopup();
          renderStudentList();
        } catch (e) {
          console.error(e);
          alert("Failed to delete. Please try again.");
        }
      };
    }, 50);
  })();
}
    // ======================= SETTINGS POPUP =====================
    function showSettingsPopup() {
  showPopup(`
    <div class="popup-title">Section Tools</div>
    <div style="display:flex;flex-direction:column;gap:13px;">
      <button class="popup-action-btn" id="uploadStudentsBtn">Upload Students (Excel)</button>
      <button class="popup-action-btn" id="yearPlanBtn">Home work & Exam Syllabus</button>
      <button class="popup-action-btn" id="onlineClassBtn">Online Classes</button>
      <button class="popup-action-btn" id="examSettingsBtn">Exam Settings</button>
      <button class="popup-action-btn" id="uploadMarksBtn">Upload Marks (Excel)</button>
      <button class="popup-action-btn" id="enterMarksBtn">Enter Marks</button>
      <button class="popup-action-btn" id="attendanceBtn">Take Attendance (WhatsApp)</button>
      <button class="popup-action-btn" id="viewAttendanceBtn">View Attendance</button>
      <button class="popup-action-btn" id="absenteesPDFBtn">Absentees Report (PDF)</button>
      <button class="popup-action-btn" id="downloadMemosBtn">Download Class Marks Memos (PDF)</button>
      <button class="popup-action-btn" id="postMarksBtn">Post Marks (WhatsApp)</button>
      <button class="popup-action-btn" id="downloadHallTicketsBtn">Download Hall Tickets</button>
      <button class="popup-action-btn" id="downloadExcelBtn">Download Class Marks (Excel/Pdf)</button>
      <button class="popup-action-btn" id="performanceGraphBtn">Performance Graph</button>
      <button class="popup-action-btn" id="createCertificateBtn">Create Certificate</button>
      <button class="popup-action-btn" id="downloadCalendarBtn">Download Calendar</button>
      <button class="popup-action-btn" id="showDeletedBtn">Show Deleted Students</button>
      <button class="popup-action-btn" id="omrScannerBtn">OMR Scanner</button>
      <button class="popup-cancel-btn">Close</button>
    </div>
  `);
  document.getElementById('uploadStudentsBtn').onclick = showBulkStudentUploadPopup;
  document.getElementById('examSettingsBtn').onclick = showExamSettingsPopup;
  document.getElementById('uploadMarksBtn').onclick = showBulkMarksUploadPopup;
  document.getElementById('enterMarksBtn').onclick = showEnterMarksPopup;
  document.getElementById('attendanceBtn').onclick = showAttendancePopup;
  document.getElementById('viewAttendanceBtn').onclick = showAttendanceHistoryPopup;
  document.getElementById('postMarksBtn').onclick = function(){ window.location.href = "post-marks.html"; };
  document.getElementById('downloadMemosBtn').onclick = function() {
    window.location.href = "memos.html";
  };
  document.getElementById('downloadHallTicketsBtn').onclick = function() {
    window.location.href = "hallticket.html";
  };
  document.getElementById('downloadExcelBtn').onclick = function() {
  window.location.href = "excel.html";
};
  document.getElementById('performanceGraphBtn').onclick = function() {
  window.location.href = "performance.html";
};
  document.getElementById('showDeletedBtn').onclick = showDeletedStudentsPopup;
      document.getElementById('createCertificateBtn').onclick = openCertificateGenerator;
document.getElementById('downloadCalendarBtn').onclick = function () {
  window.location.href = "calendar-download.html";
};
    document.getElementById('yearPlanBtn').onclick = function() {
    window.location.href = "year-plan.html";
};
 document.getElementById('absenteesPDFBtn').onclick = function() {
  openAbsenteesModal();
};
// NEW: Online Class (Zoom)
document.getElementById('onlineClassBtn').onclick = function () {
  // For now just navigate; weâ€™ll wire the page next step
  window.location.href = "online-class-teacher.html";
};

// NEW: OMR Scanner
document.getElementById('omrScannerBtn').onclick = function () {
  window.location.href = "omr.html";
};

// NEW: Download Calendar
document.getElementById('downloadCalendarBtn').onclick = function () {
  window.location.href = "calendar-download.html";
};

}
// ===== Grading Defaults (school-wide) =====
const LEGACY_GRADING_SCALE = [
  { grade: 'A+', min: 95, max: 100 },
  { grade: 'A',  min: 90, max: 94.99 },
  { grade: 'B+', min: 80, max: 89.99 },
  { grade: 'B',  min: 70, max: 79.99 },
  { grade: 'C+', min: 60, max: 69.99 },
  { grade: 'C',  min: 50, max: 59.99 },
  { grade: 'D',  min: 40, max: 49.99 },
  { grade: 'F',  min: 0,  max: 39.99 }
];

// read school default stored at years/{academicYear}/settings/gradingDefault
async function readSchoolGradingDefault() {
  try {
    const ref = db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
      .collection('settings').doc('gradingDefault');
    const snap = await ref.get();
    if (!snap.exists) return null;
    const data = snap.data() || null;
    if (!data || !Array.isArray(data.scale)) return null;
    return { mode: data.mode || 'custom', scale: data.scale };
  } catch (e) {
    console.warn('readSchoolGradingDefault error:', e);
    return null;
  }
}

// write school default (called when admin chooses â€œset as school defaultâ€)
async function writeSchoolGradingDefault(scale, meta = {}) {
  const ref = db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
    .collection('settings').doc('gradingDefault');
  const payload = {
    mode: 'custom',
    scale: Array.isArray(scale) ? scale : [],
    updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
    updatedBy: (window.currentUserEmail || ''),
    source: meta || {}
  };
  return ref.set(payload, { merge: true });
}

// simple validator: ordered ranges, no overlaps, 0â€“100 coverage optional
function validateGradingScale(scale) {
  if (!Array.isArray(scale) || !scale.length) return false;
  const rows = scale.map(r => ({
    grade: String(r.grade || '').trim(),
    min: Number(r.min),
    max: Number(r.max)
  })).filter(r => r.grade && !Number.isNaN(r.min) && !Number.isNaN(r.max));
  if (!rows.length) return false;
  // sort descending by min so A+â€¦F appears first if provided that way
  rows.sort((a, b) => b.min - a.min);
  for (let i = 0; i < rows.length; i++) {
    const r = rows[i];
    if (r.min < 0 || r.max > 100 || r.min > r.max) return false;
    if (i > 0) {
      const p = rows[i - 1];
      if (r.max > p.min) return false; // overlap check (assuming sorted by min desc)
    }
  }
  return true;
}

// resolve which scale to use for an exam (exam â†’ school default â†’ legacy)
function resolveScaleForExam(exam, schoolDefault) {
  if (exam && exam.grading && Array.isArray(exam.grading.scale) && validateGradingScale(exam.grading.scale)) {
    return exam.grading.scale;
  }
  if (schoolDefault && Array.isArray(schoolDefault.scale) && validateGradingScale(schoolDefault.scale)) {
    return schoolDefault.scale;
  }
  return LEGACY_GRADING_SCALE;
}

// compute a grade string from percentage using a given scale
function gradeFromPercent(pct, scale) {
  const s = Array.isArray(scale) ? scale : LEGACY_GRADING_SCALE;
  for (const row of s) {
    if (pct >= Number(row.min) && pct <= Number(row.max)) return row.grade;
  }
  return 'Ungraded';
}

// ===== EFFECTIVE EXAMS (group defaults + class overrides) =====
async function fetchEffectiveExams(classId, className) {
  const group = getClassGroupName(className);

  // 1) Load group exams (baseline)
  const groupSnap = await db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
    .collection('exams').doc('classGroups')
    .collection(group).get();

  const map = new Map(); // id -> exam
  groupSnap.forEach(d => {
    map.set(d.id, { id: d.id, ...d.data(), __origin: 'group' });
  });

  // 2) Load class overrides (middle precedence)
  const classSnap = await db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
    .collection('classes').doc(classId)
    .collection('examOverrides').get();

  classSnap.forEach(doc => {
    const o = doc.data() || {};

    if (o.origin === 'class-only') {
      map.set(doc.id, { id: doc.id, ...o, __origin: 'class-only' });
      return;
    }

    if (o.hidden === true) {
      map.delete(doc.id);
      return;
    }

    if (map.has(doc.id)) {
      const base = map.get(doc.id);
      map.set(doc.id, {
        ...base,
        name:        (o.name ?? base.name),
        subjects:    (Array.isArray(o.subjects) && o.subjects.length ? o.subjects : base.subjects),
        subtopics:   (Array.isArray(o.subtopics) && o.subtopics.length ? o.subtopics : base.subtopics),
        grading:     (o.grading || base.grading),
        __origin:    'class-overridden'
      });
    } else {
      map.set(doc.id, { id: doc.id, ...o, __origin: 'class-only' });
    }
  });

  // 3) Load section overrides (highest precedence)
  const sectionSnap = await db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
    .collection('classes').doc(classId)
    .collection('sections').doc(currentSectionId)
    .collection('examOverrides').get();

  sectionSnap.forEach(doc => {
    const o = doc.data() || {};

    if (o.origin === 'section-only') {
      map.set(doc.id, { id: doc.id, ...o, __origin: 'section-only' });
      return;
    }

    if (o.hidden === true) {
      map.delete(doc.id);
      return;
    }

    if (map.has(doc.id)) {
      const base = map.get(doc.id);
      map.set(doc.id, {
        ...base,
        name:        (o.name ?? base.name),
        subjects:    (Array.isArray(o.subjects) && o.subjects.length ? o.subjects : base.subjects),
        subtopics:   (Array.isArray(o.subtopics) && o.subtopics.length ? o.subtopics : base.subtopics),
        grading:     (o.grading || base.grading),
        __origin:    'section-overridden'
      });
    } else {
      map.set(doc.id, { id: doc.id, ...o, __origin: 'section-only' });
    }
  });

  // 4) Return a sorted list (by name)
  const list = Array.from(map.values());
  list.sort((a, b) => String(a.name || '').localeCompare(String(b.name || '')));
  return list;
}

// --- shim: keep both names working safely ---
if (typeof getExamsForCurrentClass !== 'function' && typeof fetchEffectiveExams === 'function') {
  // expose legacy name
  var getExamsForCurrentClass = function() {
    return fetchEffectiveExams(currentClassId, currentClassName, { forceRefresh: true });
  };
}
if (typeof fetchEffectiveExams !== 'function' && typeof getExamsForCurrentClass === 'function') {
  // expose new name
  var fetchEffectiveExams = function(classId, className) {
    return getExamsForCurrentClass();
  };
}
// ========== EXAM SETTINGS ===========
function showExamSettingsPopup() {
  const classGroup = getClassGroupName(currentClassName);

  Promise.all([
  fetchEffectiveExams(currentClassId, currentClassName, { forceRefresh: true }), // force fresh list
  db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
    .collection('classes').doc(currentClassId)
    .collection('examOverrides').limit(1).get(),          // class overrides snapshot
  db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
    .collection('classes').doc(currentClassId)
    .collection('sections').doc(currentSectionId)
    .collection('examOverrides').limit(1).get(),          // section overrides snapshot
  readSchoolGradingDefault()
]).then(([examsEff, classOverSnap, sectionOverSnap, schoolDefault]) => {
  const preloadScale = (schoolDefault && Array.isArray(schoolDefault.scale) && schoolDefault.scale.length)
    ? schoolDefault.scale
    : LEGACY_GRADING_SCALE;

  const hasSection = !sectionOverSnap.empty;
  const hasClass   = !classOverSnap.empty;
  const activeScope = hasSection ? 'section' : (hasClass ? 'class' : 'group');

  const sourceChip =
    activeScope === 'section'
      ? 'Customized for this section'
      : activeScope === 'class'
        ? 'Customized for this class'
        : 'Using inherited defaults';

    const exams = (() => {
  const list = Array.isArray(examsEff) ? examsEff : [];
  const byKey = new Map();

  // precedence: section > class > group
  const rank = (ex) => {
  const o = (ex && ex.__origin) || '';
  const s = (ex && ex.__scope) || '';
  if (o === 'section-overridden' || o === 'section-only' || (o === 'overridden' && s === 'section')) return 4;
  if (o === 'class-overridden'   || o === 'class-only'   || (o === 'overridden' && (s === 'class' || !s))) return 3;
  return 1; // inherited/group
};


  for (const e of list) {
    const k = (e.nameKey || normalizeExamName(e.name || '') || e.id || '').toString();
    if (!k) continue;
    const prev = byKey.get(k);
    if (!prev || rank(e) >= rank(prev)) byKey.set(k, e); // override lower-rank with higher-rank
  }

  return Array.from(byKey.values());
})();
    window.__sp_allExams = exams;
    let html = `
        <div class="popup-title">Exam Settings</div>

<!-- Source banner + mode toggles (separate lines) -->
<div style="text-align:center;width:100%;padding:8px 10px;margin:6px 0 12px 0;
            border-radius:10px;border:1px solid ${activeScope === 'group' ? '#c7d7ea' : '#ffd7a6'};
            background:${activeScope === 'group' ? '#e8f3ff' : '#fff3e0'};
            color:${activeScope === 'group' ? '#0f3d6b' : '#b05300'};font-weight:600;">
  ${activeScope === 'section'
      ? 'Customized for this section'
      : activeScope === 'class'
        ? 'Customized for this class'
        : 'Using inherited defaults'}
</div>

<!-- Three mutually exclusive options (group / class / section), one per line -->
<label style="display:flex;align-items:center;gap:8px;margin:4px 0;color:#444;">
  <input type="checkbox" id="modeGroup"   ${activeScope === 'group'   ? 'checked' : ''} />
  <span>Use group exams</span>
</label>
<label style="display:flex;align-items:center;gap:8px;margin:4px 0;color:#444;">
  <input type="checkbox" id="modeClass"   ${activeScope === 'class'   ? 'checked' : ''} />
  <span>Customize for this class</span>
</label>
<label style="display:flex;align-items:center;gap:8px;margin:4px 0 10px 0;color:#444;">
  <input type="checkbox" id="modeSection" ${activeScope === 'section' ? 'checked' : ''} />
  <span>Customize for this section</span>
</label>

<div id="examListArea" style="min-height:25vh;max-height:45vh;overflow-y:auto;margin-bottom:12px;">
          ${exams.length === 0 
  ? '<div style="color:#888;font-style:italic;">No exams found.</div>' 
  : exams.map((exam, idx) => {
      const badge =
  (exam.__origin === 'section-only' || exam.__origin === 'section-overridden' ||
   (exam.__origin === 'overridden' && exam.__scope === 'section'))
    ? '<span style="margin-left:8px;font-size:.8em;padding:2px 8px;border-radius:999px;background:#fff7e6;color:#a26100;border:1px solid #ffd79a;">Section override</span>'
  : (exam.__origin === 'class-only' || exam.__origin === 'class-overridden' ||
     (exam.__origin === 'overridden' && (exam.__scope === 'class' || !exam.__scope)))
    ? '<span style="margin-left:8px;font-size:.8em;padding:2px 8px;border-radius:999px;background:#eaf8ea;color:#207a2b;border:1px solid #9fddb1;">Class override</span>'
    : '<span style="margin-left:8px;font-size:.8em;padding:2px 8px;border-radius:999px;background:#e8f3ff;color:#0f3d6b;border:1px solid #c7d7ea;">Inherited</span>';

     return `
      <div style="border-bottom:1px solid #f1f1f1;margin-bottom:7px;padding-bottom:7px;">
        <strong>${exam.name}</strong>${badge}
        ${isAdmin ? `<button type="button" class="popup-action-btn"
                              data-edit="${exam.id}"      
                              style="margin-left:10px;padding:2px 8px;font-size:0.9em;">Edit</button>` : ''}
        <div style="margin-top:6px;margin-left:8px;font-size:0.99em;">
        ${Array.isArray(exam.subjects) && exam.subjects.length > 0
          ? exam.subjects.map(subj => {
              const opt = subj && subj.excludeFromTotal ? ' <span style="color:#a15d00; font-weight:600;">[Optional]</span>' : '';
              const _mode = (subj && typeof subj.subtopicsMode === 'string')
                ? subj.subtopicsMode
                : (Array.isArray(subj?.subtopics) && subj.subtopics.length ? 'custom' : 'common');
              const subs = (_mode === 'custom' && Array.isArray(subj.subtopics) && subj.subtopics.length)
                ? ` <span style="color:#1762a7;">[${subj.subtopics.map(st => `${st.name} (${st.max})`).join(', ')}]</span>`
                : '';
              return `${subj.name} <span style="color:#888;">(Max: ${subj.max})</span>${opt}${subs}`;
            }).join(', ')
          : '<span style="color:#aaa;">No subjects</span>'
        }
        </div>
        <div style="margin-top:4px;margin-left:8px;font-size:0.95em;color:#444;">
          ${
            Object.prototype.hasOwnProperty.call(exam, 'subtopics')
              ? (Array.isArray(exam.subtopics) && exam.subtopics.length > 0
                  ? 'Subtopics: ' + exam.subtopics.map(st => `${st.name} <span style="color:#888;">(${st.max})</span>`).join(', ')
                  : '')
              : ''
          }
        </div>
      </div>
    `;
    }).join('')}
        </div>
        ${isAdmin ? `
      <form id="addExamForm" style="display:flex; flex-direction:column; max-height:58vh;">
        <div style="flex:1; overflow-y:auto; padding-right:4px;">
          <label>Exam Name</label>
        <input name="examName" maxlength="30" required placeholder="e.g., FA1">
        
        <label>Subtopics <span style="color:#888;font-weight:500;">(optional)</span></label>

<!-- Internal (simple row + collapsible config) -->
<div style="display:flex; align-items:center; gap:8px; margin:6px 0 8px 0;">
  <input type="checkbox" id="useInternalToggle" style="margin:0;" />
  <label for="useInternalToggle" style="font-weight:600; margin:0;">Use Internal</label>
</div>

<div id="internalConfig" style="display:none; margin:6px 0 12px 0;">
  <div style="margin-bottom:8px;">
    <div style="font-size:0.95em; color:#1762a7; font-weight:600; margin-bottom:6px;">Source Exams</div>
    <div class="custom-dropdown" id="internalExamsDropdown" tabindex="0">
      <div class="dropdown-selected" id="internalExamsSelected" data-values="">--Select--</div>
      <div class="dropdown-list" id="internalExamsList" style="display:none; max-height:220px; overflow-y:auto;">
        ${exams.map(ex => `
          <label class="dropdown-option" style="display:flex; align-items:center; gap:10px; padding:10px 12px; cursor:pointer;">
            <input type="checkbox" value="${ex.id}" data-name="${ex.name}" style="transform:scale(1.1);" />
            <span>${ex.name}</span>
          </label>
        `).join('')}
      </div>
    </div>
    <div style="font-size:0.85em; color:#666; margin-top:4px;">Pick one or more exams.</div>
  </div>

  <div style="display:flex; align-items:center; gap:10px;">
    <label for="internalMax" style="min-width:140px;">Internal Max (marks)</label>
    <input id="internalMax" type="number" min="1" max="200" step="1" placeholder="e.g., 20"
           style="width:120px; padding:8px; border-radius:6px; border:1px solid #c7d7ea; background:#fff;" />
  </div>
  <div style="font-size:0.85em; color:#666; margin-top:6px;">
    Studentâ€™s internal = average( score/max ) Ã— Internal Max. (Written/External is added separately by you.)
  </div>
</div>

<!-- Manual subtopics -->
<div id="subtopicsContainer"></div>
<div style="display:flex; gap:10px; margin-top:6px; margin-bottom:14px;">
  <button type="button" id="addSubtopicBtn"
          style="background:#1762a7;color:#fff; padding:7px 13px;border:none;border-radius:7px;font-weight:600;">
    + Add Subtopic
  </button>
</div>
        
                <label>Subjects</label>
        <div id="subjectsContainer"></div>
        <button type="button" id="addSubjectBtn"
            style="margin:6px 0 14px 0; background:#1762a7;color:#fff;
                   padding:7px 13px;border:none;border-radius:7px;font-weight:600;">
            + Add Subject
          </button>

        <!-- ===== Grading System (school-wide default prefilled) ===== -->
        <div style="margin-top:6px; border-top:1px solid #eef3f9; padding-top:10px;">
          <label style="display:flex; align-items:center; gap:10px;">
            <span>Grading System</span>
            <span style="font-size:0.85em; color:#666;">(Prefilled from School Default if set; otherwise legacy)</span>
          </label>

        ${(activeScope === 'group' && isAdmin) ? `
  <div style="display:flex; align-items:center; gap:12px; margin:8px 0 6px 0;">
    <label style="display:flex; align-items:center; gap:8px; margin:0;">
      <input type="checkbox" id="setAsSchoolDefault" checked />
      <span>Set this as <strong>School Default</strong> for all classes</span>
    </label>
  </div>` : ``}
  
          <div id="gradingRows" style="display:grid; grid-template-columns:120px 1fr 1fr 70px; gap:8px; align-items:center;">
            <div style="font-weight:700; color:#1762a7;">Grade</div>
            <div style="font-weight:700; color:#1762a7;">Min %</div>
            <div style="font-weight:700; color:#1762a7;">Max %</div>
            <div></div>
            ${
              (preloadScale || []).map((r, i) => `
                <input type="text" class="grade-name" value="${r.grade}" placeholder="A+" style="padding:8px; border:1px solid #c7d7ea; border-radius:6px; background:#f7fafd;">
                <input type="number" class="grade-min" value="${r.min}" step="0.01" min="0" max="100" style="padding:8px; border:1px solid #c7d7ea; border-radius:6px; background:#f7fafd;">
                <input type="number" class="grade-max" value="${r.max}" step="0.01" min="0" max="100" style="padding:8px; border:1px solid #c7d7ea; border-radius:6px; background:#f7fafd;">
                ${isAdmin ? `<button type="button" class="option-btn remove-grade" style="width:70px; padding:5px;">Remove</button>` : `<div></div>`}
              `).join('')
            }
          </div>

          ${isAdmin ? `
          <div style="margin-top:8px;">
            <button type="button" id="addGradeRowBtn"
              style="background:#1762a7;color:#fff;padding:7px 13px;border:none;border-radius:7px;font-weight:600;">
              + Add Grade Row
            </button>
          </div>` : ''}
        </div>
        <!-- ===== /Grading System ===== -->

        </div>
        <div class="popup-btn-row" style="margin-top:10px;">
          <button type="button" class="popup-cancel-btn">Close</button>
          <button type="submit" class="popup-action-btn">Add Exam</button>
        </div>
      </form>
      ` : `
      <div class="popup-btn-row" style="margin-top:10px;">
        <button type="button" class="popup-cancel-btn">Close</button>
      </div>
      `}
      `;
      showPopup(html, 'addExamForm', function (e) {
        e.preventDefault();
        const name = e.target.examName.value.trim();
        const nameKey = normalizeExamName(name); // Normalize for comparison
        let subjects = [];
        const container = popupContent.querySelector('#subjectsContainer');
        if (container) {
          const subjectDivs = container.querySelectorAll('div[data-subject-row]');
          subjectDivs.forEach(div => {
  const subjInput = div.querySelector('input[type="text"]');
  const marksInput = div.querySelector('input[type="number"]');
  const optInput  = div.querySelector('.subject-opt');
  const wrap = div.querySelector('[data-subtopics-wrap]');
  const subjName = subjInput ? subjInput.value.trim() : '';
  const maxMarks = marksInput ? parseInt(marksInput.value.trim()) : 0;
  const exclude  = !!(optInput && optInput.checked);

    // read subtopics mode
    const modeSel = div.querySelector('.subject-mode-dd .dropdown-selected');
  const subtopicsMode = modeSel ? (modeSel.dataset.mode || 'common') : 'common';

  // collect subtopics (only if "custom")
let subjSubs = [];
if (subtopicsMode === 'custom' && wrap) {
  // 1) Subject-level Internal (computed)
  const tgl = div.querySelector('.sub-int-toggle');
  if (tgl && tgl.checked) {
    const sel = div.querySelector('.sub-int-selected');
    const maxEl = div.querySelector('.sub-int-max');
    const csv = sel ? (sel.dataset.values || '') : '';
    const srcIds = csv ? csv.split(',').filter(Boolean) : [];
    const iMax = maxEl ? parseFloat(maxEl.value) : NaN;
    if (srcIds.length && !Number.isNaN(iMax) && iMax > 0) {
      subjSubs.push({
        name: 'Internal',
        max: iMax,
        computed: true,
        computeRule: 'avg_normalized_x_max',
        sources: srcIds
      });
    }
  }
  // 2) Manual subtopics
  wrap.querySelectorAll('[data-subtopic-row]').forEach(r => {
    const n = r.querySelector('input[data-subtopic-name]')?.value.trim();
    const mRaw = r.querySelector('input[data-subtopic-max]')?.value;
    const m = parseFloat(mRaw);
    if (n && !Number.isNaN(m)) subjSubs.push({ name: n, max: m });
  });
}

  if (subjName && maxMarks) {
    const payload = { name: subjName, max: maxMarks, excludeFromTotal: exclude, subtopicsMode };
   if (subtopicsMode === 'custom' && subjSubs.length) {
  const idx = subjSubs.findIndex(st => st && st.computed === true && String(st.name||'').toLowerCase() === 'internal');
  if (idx > 0) { const [it] = subjSubs.splice(idx, 1); subjSubs.unshift(it); }
  payload.subtopics = subjSubs;
}
    subjects.push(payload);
  }
});
        }
        if (!name || !subjects.length) {
  alert("Please enter exam name and at least one subject!");
  return;
}
if (!subjects.some(s => !s.excludeFromTotal)) {
  alert("At least one subject must be included in total.");
  return;
}
        // --- Subtopics (collect manual) + optional Internal (computed) + dedupe ---
let subtopics = [];
{
  const subC = popupContent.querySelector('#subtopicsContainer');
  if (subC) {
    // manual rows
    subC.querySelectorAll('div[data-subtopic-row]').forEach(div => {
      const n = div.querySelector('input[data-subtopic-name]')?.value.trim();
      const m = parseFloat(div.querySelector('input[data-subtopic-max]')?.value);
      if (n && !isNaN(m)) subtopics.push({ name: n, max: m });
    });
  }

  // Internal (computed)
  const useInt = popupContent.querySelector('#useInternalToggle')?.checked;
  if (useInt) {
    const intMaxRaw = popupContent.querySelector('#internalMax')?.value;
    const intMax = parseFloat(intMaxRaw);
    // read selected exam ids from the custom dropdown
let srcIds = [];
{
  const sel = popupContent.querySelector('#internalExamsSelected');
  const csv = sel ? (sel.dataset.values || '') : '';
  srcIds = csv ? csv.split(',').filter(Boolean) : [];
}

    // Validate
    if (!srcIds.length) {
      alert('Please select at least one source exam for Internal.');
      return;
    }
    if (!intMax || isNaN(intMax) || intMax <= 0) {
      alert('Please enter a valid Internal Max (marks).');
      return;
    }

    // push computed Internal subtopic
    subtopics.push({
      name: 'Internal',
      max: intMax,
      computed: true,
      computeRule: 'avg_normalized_x_max',  // average(score/max) * internalMax
      sources: srcIds
    });
  }

  // quiet dedupe by name (case-insensitive)
const seen = new Set();
subtopics = subtopics.filter(st => {
  const k = String(st.name || '').trim().toLowerCase();
  if (!k) return false;
  if (seen.has(k)) return false;
  seen.add(k);
  return true;
});

// ensure 'Internal' (computed) is first
if (Array.isArray(subtopics) && subtopics.length) {
  const i = subtopics.findIndex(st => st && st.computed === true && String(st.name||'').toLowerCase() === 'internal');
  if (i > 0) { const [it] = subtopics.splice(i, 1); subtopics.unshift(it); }
}
}
               // ---- Collect Grading Scale from UI (rows) ----
        let gradingScale = [];
        {
          const wrap = popupContent.querySelector('#gradingRows');
          if (wrap) {
            const names = Array.from(wrap.querySelectorAll('.grade-name'));
            const mins  = Array.from(wrap.querySelectorAll('.grade-min'));
            const maxs  = Array.from(wrap.querySelectorAll('.grade-max'));
            const n = Math.min(names.length, mins.length, maxs.length);
            for (let i = 0; i < n; i++) {
              const g  = (names[i].value || '').trim();
              const mi = parseFloat(mins[i].value);
              const ma = parseFloat(maxs[i].value);
              if (g && !isNaN(mi) && !isNaN(ma)) gradingScale.push({ grade: g, min: mi, max: ma });
            }
          }
          if (!gradingScale.length) gradingScale = LEGACY_GRADING_SCALE.slice();
          if (!validateGradingScale(gradingScale)) {
            alert('Please fix the Grading System: ranges must be valid, ordered, non-overlapping, and within 0â€“100.');
            return;
          }
        }
        const setAsSchoolDefault = !!popupContent.querySelector('#setAsSchoolDefault')?.checked;

        // Check for duplicates before adding (block only at GROUP; use same id for overrides)
// Always return a DocumentReference so the next .then(docRef) runs for all scopes
db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
  .collection('exams').doc('classGroups')
  .collection(classGroup)
  .where('nameKey', '==', nameKey)
  .get()
  .then(dupSnap => {
    const _scope = window.__sp_overrideScope || (window.__sp_useGroupExams === false ? 'class' : 'group');

    // GROUP scope â€” enforce duplicate block at group level
    if (_scope === 'group') {
      if (!dupSnap.empty) {
        alert("Exam with this (or very similar) name already exists!");
        return;
      }
      return db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
        .collection('exams').doc('classGroups')
        .collection(classGroup)
        .add({
          name, nameKey, subjects, subtopics,
          grading: { mode: 'custom', scale: gradingScale }
        }); // returns DocumentReference
    }

    // CLASS / SECTION scopes
    // If group has a matching exam (same nameKey), use that id for the override
    const matchedGroupId = !dupSnap.empty ? dupSnap.docs[0].id : null;

    if (_scope === 'class') {
      const coll = db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
        .collection('classes').doc(currentClassId)
        .collection('examOverrides');

     const ref = matchedGroupId ? coll.doc(matchedGroupId) : coll.doc();
    const origin = matchedGroupId ? 'class-overridden' : 'class-only';

  return ref.set({
  name, nameKey, subjects, subtopics,
  grading: { mode: 'custom', scale: gradingScale },
  origin,
  __scope: 'class'
}, { merge: true }).then(() => ref);
    } else {
      const coll = db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
        .collection('classes').doc(currentClassId)
        .collection('sections').doc(currentSectionId)
        .collection('examOverrides');

     const ref = matchedGroupId ? coll.doc(matchedGroupId) : coll.doc();
const origin = matchedGroupId ? 'section-overridden' : 'section-only';

return ref.set({
  name, nameKey, subjects, subtopics,
  grading: { mode: 'custom', scale: gradingScale },
  origin,
  __scope: 'section'
}, { merge: true }).then(() => ref);

    }
  })

          .then(async (docRef) => {
            if (!docRef) return; // early-exit if duplicate branch above
            // Persist school-wide default if requested
            if (setAsSchoolDefault) {
              try {
                await writeSchoolGradingDefault(gradingScale, { classGroup, examId, examName: name });
              } catch (e) {
                console.warn('writeSchoolGradingDefault failed:', e);
              }
            }
            closePopup();
// Force re-fetch so that subtopics & subjects reflect immediately in Enter Marks
fetchEffectiveExams(currentClassId, currentClassName, { forceRefresh: true }).then(() => {
  showExamSettingsPopup();
});
          })
          .catch(err => {
            alert('Error adding exam: ' + (err?.message || err));
          });
      });
  // Persist the user's scope choice during this popup session (three options, mutually exclusive)
const tGroup   = popupContent.querySelector('#modeGroup');
const tClass   = popupContent.querySelector('#modeClass');
const tSection = popupContent.querySelector('#modeSection');

function setScope(scope) {
  // canonical scope used everywhere now
  window.__sp_overrideScope = scope; // 'group' | 'class' | 'section'
  // backward-compat flag (some old code still checks it)
  window.__sp_useGroupExams = (scope === 'group');

  if (tGroup)   tGroup.checked   = (scope === 'group');
  if (tClass)   tClass.checked   = (scope === 'class');
  if (tSection) tSection.checked = (scope === 'section');
}

setScope(activeScope); // initialize

if (tGroup)   tGroup.addEventListener('change',   () => setScope('group'));
if (tClass)   tClass.addEventListener('change',   () => setScope('class'));
if (tSection) tSection.addEventListener('change', () => setScope('section'));

    // --- Subtopic Fields Logic (manual rows) + Internal controls ---
const subtopicsContainer  = popupContent.querySelector('#subtopicsContainer');
const addSubtopicBtn      = popupContent.querySelector('#addSubtopicBtn');

// Internal UI
const useInternalToggle   = popupContent.querySelector('#useInternalToggle');
const internalConfigBox   = popupContent.querySelector('#internalConfig');
const internalSelect      = popupContent.querySelector('#internalSourceExams');
const internalMaxInput    = popupContent.querySelector('#internalMax');

// Internal custom dropdown (checkbox list) â€” same behavior as your other dropdowns
const internalDD     = popupContent.querySelector('#internalExamsDropdown');
const internalDDSel  = popupContent.querySelector('#internalExamsSelected');
const internalDDList = popupContent.querySelector('#internalExamsList');

function _updateInternalSelectedText() {
  const checked = internalDDList ? Array.from(internalDDList.querySelectorAll('input[type="checkbox"]:checked')) : [];
  const names = checked.map(c => c.getAttribute('data-name'));
  internalDDSel.textContent = names.length ? names.join(', ') : '--Select--';
  internalDDSel.dataset.values = checked.map(c => c.value).join(',');
}

if (internalDD && internalDDSel && internalDDList) {
  internalDDSel.onclick = function () {
    internalDDList.style.display = (internalDDList.style.display === 'none' || internalDDList.style.display === '') ? 'block' : 'none';
  };
  document.addEventListener('click', function handler(e) {
    if (!internalDD.contains(e.target)) {
      internalDDList.style.display = 'none';
      document.removeEventListener('click', handler);
    }
  });
  internalDDList.addEventListener('change', _updateInternalSelectedText);
}

if (useInternalToggle) {
  useInternalToggle.onchange = () => {
    internalConfigBox.style.display = useInternalToggle.checked ? 'block' : 'none';
  };
}

function addSubtopicField(name = '', max = '') {
  const idx = subtopicsContainer.children.length;
  const div = document.createElement('div');
  div.setAttribute('data-subtopic-row', '');
  div.style = 'display:flex;align-items:center;gap:8px;margin-bottom:7px;';
  div.innerHTML = `
    <input type="text" data-subtopic-name placeholder="Subtopic Name" value="${name}"
           required style="width:80%; padding: 8px; border-radius: 6px; border: 1px solid #c7d7ea; background: #f7fafd; margin-right:7px;" />
    <input type="number" data-subtopic-max placeholder="Max Marks" step="0.01"
           value="${max}" required style="width:25%; padding: 8px; border-radius: 6px; border: 1px solid #c7d7ea; background: #f7fafd;" />
    ${isAdmin ? `<button type="button" class="option-btn" style="width: 70px; padding: 5px;" onclick="this.parentNode.remove()">Remove</button>` : ''}
  `;
  subtopicsContainer.appendChild(div);
}

if (addSubtopicBtn) {
  addSubtopicBtn.onclick = () => addSubtopicField();
}

            // --- Subject Fields Logic (name + integer max) ---
      const subjectsContainer = popupContent.querySelector('#subjectsContainer');
      const addSubjectBtn = popupContent.querySelector('#addSubjectBtn');

    function addSubjectField(name = '', max = '', exclude = false, subtopics = [], subtopicsMode = 'common') {
  const div = document.createElement('div');
  div.setAttribute('data-subject-row', '');
  div.style = 'display:flex;flex-direction:column;gap:6px;margin-bottom:12px;border-bottom:1px solid #f1f1f1;padding-bottom:10px;';

  // Row 1: name (left) + max (right)
  const row1 = document.createElement('div');
  row1.style = 'display:flex;align-items:center;gap:10px;';
  row1.innerHTML = `
    <input type="text" placeholder="Subject Name" value="${name}"
           required style="flex:1 1 75%; min-width:0; padding:8px; border-radius:6px; border:1px solid #c7d7ea; background:#f7fafd;" />
    <input type="number" placeholder="Max" min="1" max="200" step="1"
           value="${max}" required style="flex:0 0 110px; width:110px; padding:8px; text-align:right; border-radius:6px; border:1px solid #c7d7ea; background:#f7fafd;" />
  `;

     // Row 2: Subtopics mode + Exclude (separate row under Subject Name/Max)
  const row2 = document.createElement('div');
  row2.className = 'subject-meta-row';
  row2.innerHTML = `
    <div class="custom-dropdown subject-mode-dd">
      <div class="dropdown-selected" data-mode="${subtopicsMode || (Array.isArray(subtopics)&&subtopics.length ? 'custom' : 'common')}">
        ${(subtopicsMode || (Array.isArray(subtopics)&&subtopics.length ? 'custom' : 'common')).replace(/^./, c => c.toUpperCase())}
      </div>
      <div class="dropdown-list" style="display:none;">
        <div class="dropdown-option" data-value="common">Common</div>
        <div class="dropdown-option" data-value="custom">Custom</div>
        <div class="dropdown-option" data-value="none">None</div>
      </div>
    </div>
    <label class="exclude-total"><input type="checkbox" class="subject-opt" ${exclude ? 'checked' : ''} /> Exclude from total</label>
  `;

  // Row 3: Actions (right aligned)
  const row3 = document.createElement('div');
  row3.style = 'display:flex;align-items:center;justify-content:flex-end;gap:8px;';
  row3.innerHTML = `
    <button type="button" class="option-btn toggle-subtopics" style="padding:6px 10px;">Subtopics</button>
    ${isAdmin ? `<button type="button" class="option-btn" style="padding:6px 10px;" onclick="this.closest('[data-subject-row]').remove()">Remove</button>` : ''}
  `;

     // Initialize mode â†’ show panel only for "custom"
    setTimeout(() => {
    const dd = row2.querySelector('.subject-mode-dd');
    if (!dd) return;
    const sel = dd.querySelector('.dropdown-selected');
    const list = dd.querySelector('.dropdown-list');
    const sync = () => { panel.style.display = (sel.dataset.mode === 'custom') ? 'block' : 'none'; };

    sel.onclick = () => { list.style.display = (list.style.display === 'block' ? 'none' : 'block'); };
    list.querySelectorAll('.dropdown-option').forEach(opt => {
      opt.onclick = () => {
        sel.dataset.mode = opt.dataset.value || 'common';
        sel.textContent = sel.dataset.mode.replace(/^./, c => c.toUpperCase());
        list.style.display = 'none';
        sync();
      };
    });
    document.addEventListener('click', function handler(e) {
      if (!dd.contains(e.target)) {
        list.style.display = 'none';
        document.removeEventListener('click', handler);
      }
    });

    sync();
  }, 0);


  // Subtopics panel (collapsed by default)
  const panel = document.createElement('div');
  panel.className = 'subject-subtopics';
  panel.style = 'display:none; background:#f9fcff; border:1px solid #e0ecfb; border-radius:8px; padding:8px;';
  panel.innerHTML = `
    <div style="font-weight:600;color:#1762a7; margin-bottom:6px;">Subtopics for this subject</div>

    <!-- Subject-level Internal (computed) -->
    <div style="display:flex; align-items:center; gap:10px; margin:4px 0 8px 0;">
      <input type="checkbox" class="sub-int-toggle" style="margin:0;" />
      <label style="font-weight:600; margin:0;">Use Internal (subject)</label>
    </div>

    <div class="sub-int-config" style="display:none; margin:6px 0 10px 0;">
      <div style="font-size:0.95em; color:#1762a7; font-weight:600; margin-bottom:6px;">Source Exams</div>
      <div class="custom-dropdown sub-int-dd" tabindex="0">
        <div class="dropdown-selected sub-int-selected" data-values="">--Select--</div>
        <div class="dropdown-list sub-int-list" style="display:none; max-height:220px; overflow-y:auto;">
          ${ (window.__sp_allExams || []).map(ex => `
            <label class="dropdown-option" style="display:flex; align-items:center; gap:10px; padding:10px 12px; cursor:pointer;">
              <input type="checkbox" value="${ex.id}" data-name="${ex.name}" style="transform:scale(1.1);" />
              <span>${ex.name}</span>
            </label>
          `).join('') }
        </div>
      </div>
      <div style="font-size:0.85em; color:#666; margin-top:4px;">Pick one or more exams.</div>

      <div style="display:flex; align-items:center; gap:10px; margin-top:8px;">
        <label style="min-width:140px;">Internal Max (marks)</label>
        <input type="number" class="sub-int-max" min="1" max="200" step="1" placeholder="e.g., 10 or 20"
               style="width:120px; padding:8px; border-radius:6px; border:1px solid #c7d7ea; background:#fff;" />
      </div>
      <div style="font-size:0.85em; color:#666; margin-top:6px;">
        Studentâ€™s internal = average( score/max ) Ã— Internal Max.
      </div>
    </div>

    <div data-subtopics-wrap style="display:flex;flex-direction:column;gap:6px;"></div>
    <div><button type="button" class="option-btn add-subtopic" style="margin-top:6px;">+ Add Subtopic</button></div>
    <div style="font-size:.85em;color:#666; margin-top:4px;">If subtopics are added, this subjectâ€™s total is derived from their sum.</div>
  `;

  // Assemble
  div.appendChild(row1);
  div.appendChild(row2);
  div.appendChild(row3);
  div.appendChild(panel);
  subjectsContainer.appendChild(div);


  // Wiring
const wrap   = panel.querySelector('[data-subtopics-wrap]');
const btnTgl = row3.querySelector('.toggle-subtopics');
const btnAdd = panel.querySelector('.add-subtopic');

// Subject-level Internal wiring
const subIntToggle = panel.querySelector('.sub-int-toggle');
const subIntBox    = panel.querySelector('.sub-int-config');
const subIntDD     = panel.querySelector('.sub-int-dd');
const subIntSel    = panel.querySelector('.sub-int-selected');
const subIntList   = panel.querySelector('.sub-int-list');

function _subIntUpdateText(){
  const checked = subIntList ? Array.from(subIntList.querySelectorAll('input[type="checkbox"]:checked')) : [];
  const names = checked.map(c => c.getAttribute('data-name'));
  if (subIntSel){
    subIntSel.textContent = names.length ? names.join(', ') : '--Select--';
    subIntSel.dataset.values = checked.map(c => c.value).join(',');
  }
}

if (subIntToggle && subIntBox){
  subIntToggle.onchange = () => { subIntBox.style.display = subIntToggle.checked ? 'block' : 'none'; };
}
if (subIntDD && subIntSel && subIntList){
  subIntSel.onclick = function(){
    subIntList.style.display = (subIntList.style.display === 'none' || subIntList.style.display === '') ? 'block' : 'none';
  };
  document.addEventListener('click', function handler(e){
    if (!subIntDD.contains(e.target)){
      subIntList.style.display = 'none';
      document.removeEventListener('click', handler);
    }
  });
  subIntList.addEventListener('change', _subIntUpdateText);
  _subIntUpdateText();
}


  function addSubtopicRow(stName = '', stMax = '') {
    const row = document.createElement('div');
    row.setAttribute('data-subtopic-row', '');
    row.style = 'display:flex;align-items:center;gap:8px;';
    row.innerHTML = `
      <input type="text" data-subtopic-name placeholder="Subtopic Name" value="${stName}"
             style="flex:1 1 60%; min-width:180px; padding:7px; border-radius:6px; border:1px solid #c7d7ea; background:#fff;" />
      <input type="number" data-subtopic-max placeholder="Max" step="0.01" value="${stMax}"
             style="width:100px; padding:7px; text-align:right; border-radius:6px; border:1px solid #c7d7ea; background:#fff;" />
      <button type="button" class="option-btn" onclick="this.parentNode.remove()">Remove</button>
    `;
    wrap.appendChild(row);
  }

  btnTgl.onclick = () => { panel.style.display = (panel.style.display === 'none' || panel.style.display === '') ? 'block' : 'none'; };
  btnAdd.onclick = () => addSubtopicRow();

  if (Array.isArray(subtopics) && subtopics.length) {
    panel.style.display = 'block';
    subtopics.forEach(st => addSubtopicRow(st?.name || '', (st?.max ?? '').toString()));
  }
}

    if (addSubjectBtn) {
  addSubjectBtn.onclick = () => addSubjectField('', '', false, [], 'common');
  // start with one empty row
  addSubjectField('', '', false, [], 'common');
}
     // === Grading UI (Add Exam) ===
(function setupGradingUI(){
  const rowsWrap = popupContent.querySelector('#gradingRows');
  const addBtn   = popupContent.querySelector('#addGradeRowBtn');

  function _rowHtml() {
    return `
      <input type="text" class="grade-name" placeholder="A+" style="padding:8px; border:1px solid #c7d7ea; border-radius:6px; background:#f7fafd;">
      <input type="number" class="grade-min" step="0.01" min="0" max="100" style="padding:8px; border:1px solid #c7d7ea; border-radius:6px; background:#f7fafd;">
      <input type="number" class="grade-max" step="0.01" min="0" max="100" style="padding:8px; border:1px solid #c7d7ea; border-radius:6px; background:#f7fafd;">
      <button type="button" class="option-btn remove-grade" style="width:70px; padding:5px;">Remove</button>
    `;
  }

  if (addBtn && rowsWrap) {
    addBtn.onclick = () => {
      const frag = document.createElement('div');
      frag.innerHTML = _rowHtml();
      // append 4 cells (grid columns) to rowsWrap
      Array.from(frag.children).forEach(ch => rowsWrap.appendChild(ch));
    };
  }

  if (rowsWrap) {
    rowsWrap.addEventListener('click', (e) => {
      if (e.target && e.target.classList.contains('remove-grade')) {
        // remove the 4 sibling cells that make this row
        const idx = Array.from(rowsWrap.children).indexOf(e.target);
        // row structure: [grade, min, max, remove] -> remove those 4 in reverse order
        for (let k = 0; k < 4; k++) {
          const last = rowsWrap.children[idx - k];
          if (last) rowsWrap.removeChild(last);
        }
      }
    });
  }
})();
      // Attach Edit button handlers
      setTimeout(() => {
        popupContent.querySelectorAll('[data-edit]').forEach(btn => {
         btn.onclick = function() {
  const examId = btn.getAttribute('data-edit');
// use the live toggle value instead of stale data-scope on the button
const scopeNow = window.__sp_overrideScope || (window.__sp_useGroupExams === false ? 'class' : 'group');
closePopup();
showEditExamPopup(examId, scopeNow);
};
        });
      }, 200);
    });
}

// ----------- EDIT EXAM -------------
function showEditExamPopup(examId, scope) {
  const classGroup = getClassGroupName(currentClassName);
  db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
    .collection('exams').doc('classGroups')
    .collection(classGroup).doc(examId)
    .get()
    .then(async doc => {
      // scope-aware preload: prefer section/class override if in that scope
const _scope = scope || window.__sp_overrideScope || (window.__sp_useGroupExams === false ? 'class' : 'group');

const groupRef = db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
  .collection('exams').doc('classGroups')
  .collection(classGroup).doc(examId);

const classOverrideRef = db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
  .collection('classes').doc(currentClassId)
  .collection('examOverrides').doc(examId);

const sectionOverrideRef = db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
  .collection('classes').doc(currentClassId)
  .collection('sections').doc(currentSectionId)
  .collection('examOverrides').doc(examId);

// Start from the group snapshot we already have ("doc") and override if needed
let docSnap = doc;
try {
  if (_scope === 'section') {
    const s = await sectionOverrideRef.get();
    if (s.exists) {
      docSnap = s;
    } else {
      const c = await classOverrideRef.get();
      if (c.exists) docSnap = c;
    }
  } else if (_scope === 'class') {
    const c = await classOverrideRef.get();
    if (c.exists) docSnap = c;
  }
} catch (e) {
  console.warn('Edit preload (override read) failed:', e);
}

if (!docSnap || !docSnap.exists) return alert("Exam not found!");
const exam = docSnap.data();
      const schoolDefault = await readSchoolGradingDefault();
      const preloadScale = resolveScaleForExam(exam, schoolDefault);
      showPopup(`
        <form id="editExamForm" style="display:flex; flex-direction:column; max-height:75vh;">
      <div style="flex:1; overflow-y:auto; padding-right:4px;">
          <div class="popup-title">Edit Exam ${_scope === 'group' ? '(Group)' : _scope === 'class' ? '(Class Override)' : '(Section Override)'}</div>
          <label>Exam Name</label>
          <input name="examName" maxlength="30" required value="${exam.name}">
          
          <label>Subtopics <span style="color:#888;font-weight:500;">(optional)</span></label>

<!-- Internal (simple row + collapsible config) -->
<div style="display:flex; align-items:center; gap:8px; margin:6px 0 8px 0;">
  <input type="checkbox" id="editUseInternalToggle" style="margin:0;" />
  <label for="editUseInternalToggle" style="font-weight:600; margin:0;">Use Internal</label>
</div>

<div id="editInternalConfig" style="display:none; margin:6px 0 12px 0;">
  <div style="margin-bottom:8px;">
    <div style="font-size:0.95em; color:#1762a7; font-weight:600; margin-bottom:6px;">Source Exams</div>
    <div class="custom-dropdown" id="editInternalExamsDropdown" tabindex="0">
      <div class="dropdown-selected" id="editInternalExamsSelected" data-values="">--Select--</div>
      <div class="dropdown-list" id="editInternalExamsList" style="display:none; max-height:220px; overflow-y:auto;">
        <!-- items will be injected -->
      </div>
    </div>
    <div style="font-size:0.85em; color:#666; margin-top:4px;">Pick one or more exams.</div>
  </div>

  <div style="display:flex; align-items:center; gap:10px;">
    <label for="editInternalMax" style="min-width:140px;">Internal Max (marks)</label>
    <input id="editInternalMax" type="number" min="1" max="200" step="1" placeholder="e.g., 20"
           style="width:120px; padding:8px; border-radius:6px; border:1px solid #c7d7ea; background:#fff;" />
  </div>
  <div style="font-size:0.85em; color:#666; margin-top:6px;">
    Studentâ€™s internal = average( score/max ) Ã— Internal Max. (Written/External is added separately by you.)
  </div>
</div>

<!-- Manual subtopics -->
<div id="editSubtopicsContainer"></div>
<div style="display:flex; gap:10px; margin-top:6px; margin-bottom:14px;">
  <button type="button" id="editAddSubtopicBtn"
          style="background:#1762a7;color:#fff; padding:7px 13px;border:none;border-radius:7px;font-weight:600;">
    + Add Subtopic
  </button>
</div>
          
                   <label>Subjects</label>
          <div id="editSubjectsContainer"></div>
          <button type="button" id="editAddSubjectBtn"
            style="margin:6px 0 14px 0; background:#1762a7;color:#fff;
                   padding:7px 13px;border:none;border-radius:7px;font-weight:600;">
            + Add Subject
          </button>

          <!-- ===== Grading System (prefilled from school default / exam / legacy) ===== -->
          <div style="margin-top:6px; border-top:1px solid #eef3f9; padding-top:10px;">
            <label style="display:flex; align-items:center; gap:10px;">
              <span>Grading System</span>
              <span style="font-size:0.85em; color:#666;">(Prefilled; you can edit below)</span>
            </label>

            ${(_scope === 'group' && isAdmin) ? `
            <div style="display:flex; align-items:center; gap:12px; margin:8px 0 6px 0;">
              <label style="display:flex; align-items:center; gap:8px; margin:0;">
                <input type="checkbox" id="editSetAsSchoolDefault" checked />
                <span>Set this as <strong>School Default</strong> for all classes</span>
              </label>
            </div>` : ``}

            <div id="editGradingRows" style="display:grid; grid-template-columns:120px 1fr 1fr 70px; gap:8px; align-items:center;">
              <div style="font-weight:700; color:#1762a7;">Grade</div>
              <div style="font-weight:700; color:#1762a7;">Min %</div>
              <div style="font-weight:700; color:#1762a7;">Max %</div>
              <div></div>
              ${
                (preloadScale || []).map(r => `
                  <input type="text" class="edit-grade-name" value="${r.grade}" placeholder="A+" style="padding:8px; border:1px solid #c7d7ea; border-radius:6px; background:#f7fafd;">
                  <input type="number" class="edit-grade-min" value="${r.min}" step="0.01" min="0" max="100" style="padding:8px; border:1px solid #c7d7ea; border-radius:6px; background:#f7fafd;">
                  <input type="number" class="edit-grade-max" value="${r.max}" step="0.01" min="0" max="100" style="padding:8px; border:1px solid #c7d7ea; border-radius:6px; background:#f7fafd;">
                  ${isAdmin ? `<button type="button" class="option-btn edit-remove-grade" style="width:70px; padding:5px;">Remove</button>` : `<div></div>`}
                `).join('')
              }
            </div>

            ${isAdmin ? `
            <div style="margin-top:8px;">
              <button type="button" id="editAddGradeRowBtn"
                style="background:#1762a7;color:#fff;padding:7px 13px;border:none;border-radius:7px;font-weight:600;">
                + Add Grade Row
              </button>
            </div>` : ''}
          </div>
          <!-- ===== /Grading System ===== -->

          <div class="popup-btn-row" style="margin-top:10px;">
            <button type="button" class="popup-cancel-btn">Cancel</button>
            <button type="submit" class="popup-action-btn">Save Changes</button>
          </div>
        </form>
      `, 'editExamForm', function (e) {
        e.preventDefault();
        const name = e.target.examName.value.trim();
        const nameKey = normalizeExamName(name);
        let subjects = [];
        const container = popupContent.querySelector('#editSubjectsContainer');
        if (container) {
          const subjectDivs = container.querySelectorAll('div[data-subject-row]');
          subjectDivs.forEach(div => {
  const subjInput = div.querySelector('input[type="text"]');
  const marksInput = div.querySelector('input[type="number"]');
  const optInput  = div.querySelector('.subject-opt');
  const wrap = div.querySelector('[data-subtopics-wrap]');
  const subjName = subjInput ? subjInput.value.trim() : '';
  const maxMarks = marksInput ? parseInt(marksInput.value.trim()) : 0;
  const exclude  = !!(optInput && optInput.checked);

    // read subtopics mode
    const modeSel = div.querySelector('.subject-mode-dd .dropdown-selected');
  const subtopicsMode = modeSel ? (modeSel.dataset.mode || 'common') : 'common';

  // collect subtopics (only if "custom")
let subjSubs = [];
if (subtopicsMode === 'custom' && wrap) {
  // 1) Subject-level Internal (computed)
  const tgl = div.querySelector('.sub-int-toggle');
  if (tgl && tgl.checked) {
    const sel = div.querySelector('.sub-int-selected');
    const maxEl = div.querySelector('.sub-int-max');
    const csv = sel ? (sel.dataset.values || '') : '';
    const srcIds = csv ? csv.split(',').filter(Boolean) : [];
    const iMax = maxEl ? parseFloat(maxEl.value) : NaN;
    if (srcIds.length && !Number.isNaN(iMax) && iMax > 0) {
      subjSubs.push({
        name: 'Internal',
        max: iMax,
        computed: true,
        computeRule: 'avg_normalized_x_max',
        sources: srcIds
      });
    }
  }
  // 2) Manual subtopics
  wrap.querySelectorAll('[data-subtopic-row]').forEach(r => {
    const n = r.querySelector('input[data-subtopic-name]')?.value.trim();
    const mRaw = r.querySelector('input[data-subtopic-max]')?.value;
    const m = parseFloat(mRaw);
    if (n && !Number.isNaN(m)) subjSubs.push({ name: n, max: m });
  });
}

  if (subjName && maxMarks) {
    const payload = { name: subjName, max: maxMarks, excludeFromTotal: exclude, subtopicsMode };
    if (subtopicsMode === 'custom' && subjSubs.length) {
  const idx = subjSubs.findIndex(st => st && st.computed === true && String(st.name||'').toLowerCase() === 'internal');
  if (idx > 0) { const [it] = subjSubs.splice(idx, 1); subjSubs.unshift(it); }
  payload.subtopics = subjSubs;
}
    subjects.push(payload);
  }
});
        }
       if (!name || !subjects.length) {
  alert("Please enter exam name and at least one subject!");
  return;
}
if (!subjects.some(s => !s.excludeFromTotal)) {
  alert("At least one subject must be included in total.");
  return;
}
       // --- Subtopics (manual) + optional Internal (computed) + dedupe ---
let subtopics = [];

// 1) Manual rows
{
  const subC = popupContent.querySelector('#editSubtopicsContainer');
  if (subC) {
    const rows = subC.querySelectorAll('div[data-subtopic-row]');
    rows.forEach(div => {
      const nameInput = div.querySelector('input[data-subtopic-name]');
      const maxInput  = div.querySelector('input[data-subtopic-max]');
      const rawName = nameInput ? nameInput.value.trim() : '';
      const rawMax  = maxInput  ? maxInput.value.trim()  : '';
      if (!rawName) return;
      const parsed = parseFloat(rawMax);
      if (isNaN(parsed)) return;
      subtopics.push({ name: rawName, max: parsed });
    });
  }
}

// 2) Internal (computed)
{
  const useInt = popupContent.querySelector('#editUseInternalToggle')?.checked;
  if (useInt) {
    const intMaxRaw = popupContent.querySelector('#editInternalMax')?.value;
    const intMax = parseFloat(intMaxRaw);
    // read selected exam ids from custom dropdown
let srcIds = [];
{
  const sel = popupContent.querySelector('#editInternalExamsSelected');
  const csv = sel ? (sel.dataset.values || '') : '';
  srcIds = csv ? csv.split(',').filter(Boolean) : [];
}

    if (!srcIds.length) {
      alert('Please select at least one source exam for Internal.');
      return;
    }
    if (!intMax || isNaN(intMax) || intMax <= 0) {
      alert('Please enter a valid Internal Max (marks).');
      return;
    }

    subtopics.push({
      name: 'Internal',
      max: intMax,
      computed: true,
      computeRule: 'avg_normalized_x_max',  // average(score/max) * internalMax
      sources: srcIds
    });
  }
}

// 3) quiet dedupe by name (case-insensitive, trimmed); keep first
{
  const seen = new Set();
  subtopics = subtopics.filter(st => {
    const k = String(st.name || '').trim().toLowerCase();
    if (!k || seen.has(k)) return false;
    seen.add(k);
    return true;
  });

  // ensure 'Internal' (computed) is first
  if (Array.isArray(subtopics) && subtopics.length) {
    const i = subtopics.findIndex(st => st && st.computed === true && String(st.name||'').toLowerCase() === 'internal');
    if (i > 0) { const [it] = subtopics.splice(i, 1); subtopics.unshift(it); }
  }
}
        // ---- Collect Grading Scale from Edit UI ----
        let gradingScale = [];
        {
          const wrap = popupContent.querySelector('#editGradingRows');
          if (wrap) {
            const names = Array.from(wrap.querySelectorAll('.edit-grade-name'));
            const mins  = Array.from(wrap.querySelectorAll('.edit-grade-min'));
            const maxs  = Array.from(wrap.querySelectorAll('.edit-grade-max'));
            const n = Math.min(names.length, mins.length, maxs.length);
            for (let i = 0; i < n; i++) {
              const g  = (names[i].value || '').trim();
              const mi = parseFloat(mins[i].value);
              const ma = parseFloat(maxs[i].value);
              if (g && !isNaN(mi) && !isNaN(ma)) gradingScale.push({ grade: g, min: mi, max: ma });
            }
          }
          if (!gradingScale.length) gradingScale = LEGACY_GRADING_SCALE.slice();
          if (!validateGradingScale(gradingScale)) {
            alert('Please fix the Grading System: ranges must be valid, ordered, non-overlapping, and within 0â€“100.');
            return;
          }
        }
        const setAsSchoolDefault = !!popupContent.querySelector('#editSetAsSchoolDefault')?.checked;

        // Check for duplicates within the active scope (exclude this examId itself)
let dupQuery;
if (_scope === 'group') {
  dupQuery = db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
    .collection('exams').doc('classGroups')
    .collection(classGroup)
    .where('nameKey', '==', nameKey);
} else if (_scope === 'class') {
  dupQuery = db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
    .collection('classes').doc(currentClassId)
    .collection('examOverrides')
    .where('nameKey', '==', nameKey);
} else {
  dupQuery = db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
    .collection('classes').doc(currentClassId)
    .collection('sections').doc(currentSectionId)
    .collection('examOverrides')
    .where('nameKey', '==', nameKey);
}

dupQuery.get().then(dupSnap => {
            let isDuplicate = false;
            if (!dupSnap.empty) {
              dupSnap.forEach(doc => {
                if (doc.id !== examId) isDuplicate = true;
              });
              if (isDuplicate) {
                alert("Another exam with this (or very similar) name already exists in this scope!");
                return;
              }
            }
            // If not duplicate, update (use _scope defined above)

// target refs (already defined above)

// ---- Migrate marks if a subject was renamed (e.g., "tenugu" -> "TELUGU") ----
(function migrateSubjectRenames(){
  try {
    const oldSubs = Array.isArray(exam.subjects) ? exam.subjects.map(s => String(s.name || '')) : [];
    const newSubs = Array.isArray(subjects)      ? subjects.map(s => String(s.name || ''))      : [];

    // simple normalizer used in Enter Marks too
    const _norm = s => (s || '')
      .toString()
      .normalize('NFKC')
      .replace(/\s+/g, ' ')
      .trim()
      .toLowerCase();

    // tiny helper: returns true if strings are the same ignoring case OR one-edit-away (insert/delete/replace 1 char)
    function _oneEdit(a, b){
      a = (a || '').toLowerCase(); b = (b || '').toLowerCase();
      if (a === b) return true;
      const la = a.length, lb = b.length;
      if (Math.abs(la - lb) > 1) return false;
      let i = 0, j = 0, edits = 0;
      while (i < la && j < lb){
        if (a[i] === b[j]) { i++; j++; continue; }
        edits++; if (edits > 1) return false;
        if (la > lb) { i++; }       // delete in a
        else if (lb > la) { j++; }  // insert in a
        else { i++; j++; }          // replace
      }
      // tail differences
      if (i < la || j < lb) edits++;
      return edits <= 1;
    }

    // build rename map: oldName -> newName (only safe, unambiguous matches)
    const renameMap = {};
    oldSubs.forEach(oldName => {
      const oldN = _norm(oldName);
      // if new contains exact (by norm), nothing to migrate
      if (newSubs.some(ns => _norm(ns) === oldN)) return;

      // try to find a single close candidate in new
      const candidates = newSubs.filter(ns => _oneEdit(oldName, ns));
      if (candidates.length === 1) {
        renameMap[oldName] = candidates[0];
      }
    });

    // nothing to do
    if (!Object.keys(renameMap).length) return;

    // migrate within CURRENT section only (marks live per section)
    db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
      .collection('classes').doc(currentClassId)
      .collection('sections').doc(currentSectionId)
      .collection('students').orderBy('roll').get()
      .then(snap => {
        const ops = [];
        snap.forEach(stuDoc => {
          const stuId = stuDoc.id;
          const markRef = db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
            .collection('classes').doc(currentClassId)
            .collection('sections').doc(currentSectionId)
            .collection('students').doc(stuId)
            .collection('marks').doc(examId);

          ops.push(
            markRef.get().then(doc => {
              if (!doc.exists) return;
              const data = doc.data() || {};
              const updates = {};
              let needsWrite = false;

              // migrate total keys
              for (const [oldName, newName] of Object.entries(renameMap)) {
                const oldKey = Object.keys(data).find(k => k !== '__subs' && _norm(k) === _norm(oldName));
                const newExists = Object.prototype.hasOwnProperty.call(data, newName);
                if (oldKey && !newExists) {
                  updates[newName] = data[oldKey];
                  updates[oldKey]  = firebase.firestore.FieldValue.delete();
                  needsWrite = true;
                }
              }

              // migrate breakdown keys under __subs
              const subs = data.__subs && typeof data.__subs === 'object' ? data.__subs : null;
              if (subs) {
                for (const [oldName, newName] of Object.entries(renameMap)) {
                  const oldSKey = Object.keys(subs).find(k => _norm(k) === _norm(oldName));
                  const newSKey = Object.keys(subs).find(k => _norm(k) === _norm(newName));
                  if (oldSKey && !newSKey) {
                    // copy map then remove old
                    updates[`__subs.${newName}`] = subs[oldSKey];
                    updates[`__subs.${oldSKey}`] = firebase.firestore.FieldValue.delete();
                    needsWrite = true;
                  }
                }
              }

              if (needsWrite) {
                return markRef.set(updates, { merge: true });
              }
            })
          );
        });
        return Promise.all(ops);
      })
      .catch(e => console.warn('Subject rename migration skipped:', e));
  } catch (e) {
    console.warn('Subject rename migration error:', e);
  }
})();

 // ensure 'Internal' (computed) is first at exam-level (final guard)
 if (Array.isArray(subtopics) && subtopics.length) {
   const i = subtopics.findIndex(st => st && st.computed === true && String(st.name||'').toLowerCase() === 'internal');
   if (i > 0) { const [it] = subtopics.splice(i, 1); subtopics.unshift(it); }
 }

 // payload to write (after migration step)
 const payload = { 
  name, nameKey, subjects,
  grading: { mode: 'custom', scale: gradingScale }
};
// If no exam-level subtopics remain, delete the field to avoid showing stale data
if (subtopics.length > 0) {
  payload.subtopics = subtopics;
} else {
  payload.subtopics = firebase.firestore.FieldValue.delete();
}

          (async () => {
            try {
              if (_scope === 'group') {
                await groupRef.update(payload);
                if (setAsSchoolDefault) {
                  try {
                    await writeSchoolGradingDefault(gradingScale, { classGroup, examId, examName: name });
                  } catch (e) {
                    console.warn('writeSchoolGradingDefault failed:', e);
                  }
                }
              } else if (_scope === 'class') {
                await classOverrideRef.set({ ...payload, origin: 'class-overridden', __scope: 'class' }, { merge: true });
              } else {
                await sectionOverrideRef.set({ ...payload, origin: 'section-overridden', __scope: 'section' }, { merge: true });
              }
            } catch (err) {
              alert('Error saving changes: ' + (err?.message || err));
              return;
            }
            closePopup();
// Force re-fetch so that subtopics & subjects reflect immediately in Enter Marks
fetchEffectiveExams(currentClassId, currentClassName, { forceRefresh: true }).then(() => {
  showExamSettingsPopup();
});

          })();
          });
      });

      // --- Subject Fields Logic for Edit ---
      const subjectsContainer = popupContent.querySelector('#editSubjectsContainer');
      const addSubjectBtn = popupContent.querySelector('#editAddSubjectBtn');
     function addSubjectField(name = '', max = '', exclude = false, subtopics = [], subtopicsMode = 'common') {
  const idx = subjectsContainer.children.length;
  const div = document.createElement('div');
  div.setAttribute('data-subject-row', '');
  div.style = 'display:flex;flex-direction:column;gap:6px;margin-bottom:12px;border-bottom:1px solid #f1f1f1;padding-bottom:10px;';

  // Row 1
  const row1 = document.createElement('div');
  row1.style = 'display:flex;align-items:center;gap:10px;';
  row1.innerHTML = `
    <input type="text" name="subjectName_${idx}" placeholder="Subject Name" value="${name}" required
           style="flex:1 1 75%; min-width:0; padding:8px; border-radius:6px; border:1px solid #c7d7ea; background:#f7fafd;" />
    <input type="number" name="maxMarks_${idx}" placeholder="Max" min="1" max="200" value="${max}" required
           style="flex:0 0 110px; width:110px; padding:8px; text-align:right; border-radius:6px; border:1px solid #c7d7ea; background:#f7fafd;" />
  `;

   // Row 2: Subtopics mode + Exclude checkbox
    const row2 = document.createElement('div');
  row2.className = 'subject-meta-row';
  row2.innerHTML = `
    <div class="custom-dropdown subject-mode-dd">
      <div class="dropdown-selected" data-mode="${subtopicsMode || (Array.isArray(subtopics)&&subtopics.length ? 'custom' : 'common')}">
        ${(subtopicsMode || (Array.isArray(subtopics)&&subtopics.length ? 'custom' : 'common')).replace(/^./, c => c.toUpperCase())}
      </div>
      <div class="dropdown-list" style="display:none;">
        <div class="dropdown-option" data-value="common">Common</div>
        <div class="dropdown-option" data-value="custom">Custom</div>
        <div class="dropdown-option" data-value="none">None</div>
      </div>
    </div>
    <label class="exclude-total"><input type="checkbox" class="subject-opt" ${exclude ? 'checked' : ''} /> Exclude from total</label>
  `;

  // Row 3
  const row3 = document.createElement('div');
  row3.style = 'display:flex;align-items:center;justify-content:flex-end;gap:8px;';
  row3.innerHTML = `
    <button type="button" class="option-btn toggle-subtopics" style="padding:6px 10px;">Subtopics</button>
    ${isAdmin ? `<button type="button" class="option-btn" style="padding:6px 10px;" onclick="this.closest('[data-subject-row]').remove()">Remove</button>` : ''}
  `;

    // Initialize mode â†’ show panel only for "custom"
    setTimeout(() => {
    const dd = row2.querySelector('.subject-mode-dd');
    if (!dd) return;
    const sel = dd.querySelector('.dropdown-selected');
    const list = dd.querySelector('.dropdown-list');
    const sync = () => { panel.style.display = (sel.dataset.mode === 'custom') ? 'block' : 'none'; };

    // open/close
    sel.onclick = () => { list.style.display = (list.style.display === 'block' ? 'none' : 'block'); };
    // pick option
    list.querySelectorAll('.dropdown-option').forEach(opt => {
      opt.onclick = () => {
        sel.dataset.mode = opt.dataset.value || 'common';
        sel.textContent = sel.dataset.mode.replace(/^./, c => c.toUpperCase());
        list.style.display = 'none';
        sync();
      };
    });
    // click outside
    document.addEventListener('click', function handler(e) {
      if (!dd.contains(e.target)) {
        list.style.display = 'none';
        document.removeEventListener('click', handler);
      }
    });

    sync();
  }, 0);

  // Subtopics panel (collapsed by default)
  const panel = document.createElement('div');
  panel.className = 'subject-subtopics';
  panel.style = 'display:none; background:#f9fcff; border:1px solid #e0ecfb; border-radius:8px; padding:8px;';
  panel.innerHTML = `
    <div style="font-weight:600;color:#1762a7; margin-bottom:6px;">Subtopics for this subject</div>

    <!-- Subject-level Internal (computed) -->
    <div style="display:flex; align-items:center; gap:10px; margin:4px 0 8px 0;">
      <input type="checkbox" class="sub-int-toggle" style="margin:0;" />
      <label style="font-weight:600; margin:0;">Use Internal (subject)</label>
    </div>

    <div class="sub-int-config" style="display:none; margin:6px 0 10px 0;">
      <div style="font-size:0.95em; color:#1762a7; font-weight:600; margin-bottom:6px;">Source Exams</div>
      <div class="custom-dropdown sub-int-dd" tabindex="0">
        <div class="dropdown-selected sub-int-selected" data-values="">--Select--</div>
        <div class="dropdown-list sub-int-list" style="display:none; max-height:220px; overflow-y:auto;">
          ${ (window.__sp_allExams || []).map(ex => `
            <label class="dropdown-option" style="display:flex; align-items:center; gap:10px; padding:10px 12px; cursor:pointer;">
              <input type="checkbox" value="${ex.id}" data-name="${ex.name}" style="transform:scale(1.1);" />
              <span>${ex.name}</span>
            </label>
          `).join('') }
        </div>
      </div>
      <div style="font-size:0.85em; color:#666; margin-top:4px;">Pick one or more exams.</div>

      <div style="display:flex; align-items:center; gap:10px; margin-top:8px;">
        <label style="min-width:140px;">Internal Max (marks)</label>
        <input type="number" class="sub-int-max" min="1" max="200" step="1" placeholder="e.g., 10 or 20"
               style="width:120px; padding:8px; border-radius:6px; border:1px solid #c7d7ea; background:#fff;" />
      </div>
      <div style="font-size:0.85em; color:#666; margin-top:6px;">
        Studentâ€™s internal = average( score/max ) Ã— Internal Max.
      </div>
    </div>

    <div data-subtopics-wrap style="display:flex;flex-direction:column;gap:6px;"></div>
    <div><button type="button" class="option-btn add-subtopic" style="margin-top:6px;">+ Add Subtopic</button></div>
    <div style="font-size:.85em;color:#666; margin-top:4px;">If subtopics are added, this subjectâ€™s total is derived from their sum.</div>
  `;

  div.appendChild(row1);
  div.appendChild(row2);
  div.appendChild(row3);
  div.appendChild(panel);
  subjectsContainer.appendChild(div);

  const wrap   = panel.querySelector('[data-subtopics-wrap]');
const btnTgl = row3.querySelector('.toggle-subtopics');
const btnAdd = panel.querySelector('.add-subtopic');

// Subject-level Internal wiring (Edit)
const subIntToggle = panel.querySelector('.sub-int-toggle');
const subIntBox    = panel.querySelector('.sub-int-config');
const subIntDD     = panel.querySelector('.sub-int-dd');
const subIntSel    = panel.querySelector('.sub-int-selected');
const subIntList   = panel.querySelector('.sub-int-list');

function _subIntUpdateText(){
  const checked = subIntList ? Array.from(subIntList.querySelectorAll('input[type="checkbox"]:checked')) : [];
  const names = checked.map(c => c.getAttribute('data-name'));
  if (subIntSel){
    subIntSel.textContent = names.length ? names.join(', ') : '--Select--';
    subIntSel.dataset.values = checked.map(c => c.value).join(',');
  }
}

if (subIntToggle && subIntBox){
  subIntToggle.onchange = () => { subIntBox.style.display = subIntToggle.checked ? 'block' : 'none'; };
}
if (subIntDD && subIntSel && subIntList){
  subIntSel.onclick = function(){
    subIntList.style.display = (subIntList.style.display === 'none' || subIntList.style.display === '') ? 'block' : 'none';
  };
  document.addEventListener('click', function handler(e){
    if (!subIntDD.contains(e.target)){
      subIntList.style.display = 'none';
      document.removeEventListener('click', handler);
    }
  });
  subIntList.addEventListener('change', _subIntUpdateText);
  _subIntUpdateText();
}

  function addSubtopicRow(stName = '', stMax = '') {
    const r = document.createElement('div');
    r.setAttribute('data-subtopic-row', '');
    r.style = 'display:flex;align-items:center;gap:8px;';
    r.innerHTML = `
      <input type="text" data-subtopic-name placeholder="Subtopic Name" value="${stName}"
             style="flex:1 1 60%; min-width:180px; padding:7px; border-radius:6px; border:1px solid #c7d7ea; background:#fff;" />
      <input type="number" data-subtopic-max placeholder="Max" step="0.01" value="${stMax}"
             style="width:100px; padding:7px; text-align:right; border-radius:6px; border:1px solid #c7d7ea; background:#fff;" />
      <button type="button" class="option-btn" onclick="this.parentNode.remove()">Remove</button>
    `;
    wrap.appendChild(r);
  }

  btnTgl.onclick = () => { panel.style.display = (panel.style.display === 'none' || panel.style.display === '') ? 'block' : 'none'; };
  btnAdd.onclick = () => addSubtopicRow();

  if (Array.isArray(subtopics) && subtopics.length) {
    panel.style.display = 'block';
    subtopics.forEach(st => addSubtopicRow(st?.name || '', (st?.max ?? '').toString()));
  }
}
     if (exam.subjects && Array.isArray(exam.subjects)) {
  exam.subjects.forEach(subj => addSubjectField(
    subj.name,
    subj.max,
    !!subj.excludeFromTotal,
    Array.isArray(subj.subtopics) ? subj.subtopics : [],
    subj.subtopicsMode || (Array.isArray(subj.subtopics) && subj.subtopics.length ? 'custom' : 'common')
  ));
}
      addSubjectBtn.onclick = () => addSubjectField();
            // === Grading UI (Edit Exam) ===
      (function setupEditGradingUI(){
        const rowsWrap = popupContent.querySelector('#editGradingRows');
        const addBtn   = popupContent.querySelector('#editAddGradeRowBtn');

        function _rowHtml() {
          return `
            <input type="text" class="edit-grade-name" placeholder="A+" style="padding:8px; border:1px solid #c7d7ea; border-radius:6px; background:#f7fafd;">
            <input type="number" class="edit-grade-min" step="0.01" min="0" max="100" style="padding:8px; border:1px solid #c7d7ea; border-radius:6px; background:#f7fafd;">
            <input type="number" class="edit-grade-max" step="0.01" min="0" max="100" style="padding:8px; border:1px solid #c7d7ea; border-radius:6px; background:#f7fafd;">
            <button type="button" class="option-btn edit-remove-grade" style="width:70px; padding:5px;">Remove</button>
          `;
        }

        if (addBtn && rowsWrap) {
          addBtn.onclick = () => {
            const frag = document.createElement('div');
            frag.innerHTML = _rowHtml();
            Array.from(frag.children).forEach(ch => rowsWrap.appendChild(ch));
          };
        }

        if (rowsWrap) {
          rowsWrap.addEventListener('click', (e) => {
            if (e.target && e.target.classList.contains('edit-remove-grade')) {
              const idx = Array.from(rowsWrap.children).indexOf(e.target);
              for (let k = 0; k < 4; k++) {
                const last = rowsWrap.children[idx - k];
                if (last) rowsWrap.removeChild(last);
              }
            }
          });
        }
      })();

     // --- Subtopic Fields Logic for Edit (manual) + Internal controls ---
const editSubtopicsContainer = popupContent.querySelector('#editSubtopicsContainer');
const editAddSubtopicBtn     = popupContent.querySelector('#editAddSubtopicBtn');

// Internal UI (Edit)
const editUseInternalToggle  = popupContent.querySelector('#editUseInternalToggle');
const editInternalConfigBox  = popupContent.querySelector('#editInternalConfig');
// (removed legacy) no element with id="editInternalSourceExams"
const editInternalMaxInput   = popupContent.querySelector('#editInternalMax');

// helper: add one manual subtopic row
function editAddSubtopicField(name = '', max = '') {
  const div = document.createElement('div');
  div.setAttribute('data-subtopic-row', '');
  div.style = 'display:flex;align-items:center;gap:8px;margin-bottom:7px;';
  div.innerHTML = `
    <input type="text" data-subtopic-name placeholder="Subtopic Name" value="${name}"
       style="width:80%; padding: 8px; border-radius: 6px; border: 1px solid #c7d7ea; background: #f7fafd; margin-right:7px;" />
    <input type="number" data-subtopic-max placeholder="Max Marks" step="0.01"
       value="${max}" style="width:25%; padding: 8px; border-radius: 6px; border: 1px solid #c7d7ea; background: #f7fafd;" />
    ${isAdmin ? `<button type="button" class="option-btn" style="width: 70px; padding: 5px;" onclick="this.parentNode.remove()">Remove</button>` : ''}
  `;
  editSubtopicsContainer.appendChild(div);
}

// Load available exams into the dropdown (so it mirrors Add flow)
(function loadExamOptionsForEdit(){
  db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
    .collection('exams').doc('classGroups')
    .collection(getClassGroupName(currentClassName))
    .get()
    .then(snap2 => {
      const items = [];
      snap2.forEach(d => items.push({id: d.id, ...(d.data()||{})}));
      window.__sp_allExams = items;
      // Build custom checkbox list into our dropdown and prefill existing selections
const editDD      = popupContent.querySelector('#editInternalExamsDropdown');
const editDDSel   = popupContent.querySelector('#editInternalExamsSelected');
const editDDList  = popupContent.querySelector('#editInternalExamsList');

function _editUpdateInternalSelectedText() {
  const checked = editDDList ? Array.from(editDDList.querySelectorAll('input[type="checkbox"]:checked')) : [];
  const names = checked.map(c => c.getAttribute('data-name'));
  editDDSel.textContent = names.length ? names.join(', ') : '--Select--';
  editDDSel.dataset.values = checked.map(c => c.value).join(',');
}

if (editDD && editDDSel && editDDList) {
  // inject items
  editDDList.innerHTML = items.map(ex => `
    <label class="dropdown-option" style="display:flex; align-items:center; gap:10px; padding:10px 12px; cursor:pointer;">
      <input type="checkbox" value="${ex.id}" data-name="${ex.name}" style="transform:scale(1.1);" />
      <span>${ex.name}</span>
    </label>
  `).join('');

  // open/close logic
  editDDSel.onclick = function () {
    editDDList.style.display = (editDDList.style.display === 'none' || editDDList.style.display === '') ? 'block' : 'none';
  };
  document.addEventListener('click', function handler(e) {
    if (!editDD.contains(e.target)) {
      editDDList.style.display = 'none';
      document.removeEventListener('click', handler);
    }
  });
  editDDList.addEventListener('change', _editUpdateInternalSelectedText);

  // Prefill internal (computed) if present on exam
  const existingInternal = Array.isArray(exam.subtopics)
    ? exam.subtopics.find(st => st && st.computed === true && (st.name || '').toLowerCase() === 'internal')
    : null;

  if (existingInternal) {
    if (editUseInternalToggle) {
      editUseInternalToggle.checked = true;
      editInternalConfigBox.style.display = 'block';
    }
    if (editInternalMaxInput && typeof existingInternal.max !== 'undefined') {
      editInternalMaxInput.value = existingInternal.max;
    }
    if (existingInternal.sources && Array.isArray(existingInternal.sources) && existingInternal.sources.length) {
      // tick the matching checkboxes
      existingInternal.sources.forEach(id => {
        const cb = editDDList.querySelector(`input[type="checkbox"][value="${id}"]`);
        if (cb) cb.checked = true;
      });
    }
    _editUpdateInternalSelectedText();
  } else {
    _editUpdateInternalSelectedText();
  }
}
    });
})();

// Toggle show/hide
if (editUseInternalToggle) {
  editUseInternalToggle.onchange = () => {
    editInternalConfigBox.style.display = editUseInternalToggle.checked ? 'block' : 'none';
  };
}

// Prefill manual subtopics ONLY (skip computed internal)
if (exam.subtopics && Array.isArray(exam.subtopics) && exam.subtopics.length) {
  exam.subtopics
    .filter(st => !(st && st.computed === true && (st.name || '').toLowerCase() === 'internal'))
    .forEach(st => editAddSubtopicField(st?.name || '', (st?.max ?? '').toString()));
}

// Add manual subtopic button
if (editAddSubtopicBtn) {
  editAddSubtopicBtn.onclick = () => editAddSubtopicField();
}
    });
}

   // ============= ENTER MARKS ===============
function showEnterMarksPopup() {
  console.log('showEnterMarksPopup called');
  console.log('academicYear:', academicYear);
 fetchEffectiveExams(currentClassId, currentClassName, { forceRefresh: true }).then(exams => {
  if (!Array.isArray(exams) || exams.length === 0) {
    showPopup(`<div class="popup-title">Enter Marks</div>
      <div style="margin:16px 0;">No exams found! Please add exams first.</div>
      <div class="popup-btn-row"><button class="popup-cancel-btn">Close</button></div>
    `);
    return;
  }
  let html = `
        <form id="selectExamForm">
          <div class="popup-title">Enter Marks</div>
          <label>Select Exam</label>
          <div class="custom-dropdown" id="examDropdown" tabindex="0">
            <div class="dropdown-selected" id="examSelected" data-value="">--Select--</div>
            <div class="dropdown-list" id="examList" style="display:none;"></div>
          </div>
          <label>Select Subject</label>
          <div class="custom-dropdown" id="subjectDropdown" tabindex="0">
            <div class="dropdown-selected" id="subjectSelected" data-value="">--Select Exam First--</div>
            <div class="dropdown-list" id="subjectList" style="display:none;"></div>
          </div>
          <div class="popup-btn-row">
            <button type="button" class="popup-cancel-btn">Cancel</button>
            <button type="submit" class="popup-action-btn">Next</button>
          </div>
        </form>
      `;
      showPopup(html, 'selectExamForm', function(e) {
        e.preventDefault();
        // Get selected values
        const examId = document.getElementById('examSelected').dataset.value;
        const subjectName = document.getElementById('subjectSelected').dataset.value;
        if (!examId || !subjectName) return;
        db.collection('schools').doc(schoolId).collection('years').doc(academicYear).collection('classes').doc(currentClassId)
          .collection('sections').doc(currentSectionId)
          .collection('students').orderBy('roll').get().then(stuSnap => {
            let students = [];
            stuSnap.forEach(doc => {
              const data = doc.data();
              if (!data.isDeleted && data.isDeleted !== "true" && data.isDeleted !== 1) {
                students.push({ id: doc.id, ...data });
              }
            });
            const exam = (Array.isArray(exams) ? exams.find(ex => ex.id === examId) : null);
if (!exam) {
  alert('Selected exam is unavailable. Please pick another.');
  return;
}
const subj = Array.isArray(exam.subjects) ? exam.subjects.find(s => s.name === subjectName) : null;
const max = subj ? subj.max : 100;

// honor subject-level subtopics mode: 'custom' | 'common' | 'none'
let subtopics = [];
const mode =
  (subj && typeof subj.subtopicsMode === 'string') ? subj.subtopicsMode :
  (Array.isArray(subj?.subtopics) && subj.subtopics.length > 0) ? 'custom' :
  (Array.isArray(exam.subtopics) && exam.subtopics.length > 0) ? 'common' :
  'none';

if (mode === 'custom') {
  subtopics = Array.isArray(subj?.subtopics) ? subj.subtopics : [];
} else if (mode === 'common') {
  subtopics = Array.isArray(exam.subtopics) ? exam.subtopics : [];
} else {
  subtopics = []; // none
}

console.log('Subject:', subjectName, 'mode:', mode, 'Subtopics count:', subtopics.length, subtopics);
            
            // --- Begin: Marks Entry Popup Block ---
const hasSubs = (subtopics.length > 0) && (mode === 'custom' || mode === 'common');
let marksData = {};       // overall total per student (number)
let breakdownData = {};   // per-subtopic map per student (object)

function _normKey(s) {
  return (s || '')
    .toString()
    .normalize('NFKC')
    .replace(/\s+/g, ' ')
    .trim()
    .toLowerCase();
}
            function _resolveSubKeyExact(obj, wantName) {
  if (!obj) return null;
  const want = _normKey(wantName);
  const keys = Object.keys(obj);
  // exact normalized match only (no single-key fallback!)
  const k = keys.find(x => _normKey(x) === want);
  return k || null;
}

// ---- Internal calculator (ABSENT/MISSING = 0; skip if max<=0) ----
function _computeInternalFromArray(sourceItems, internalMax) {
  if (!Array.isArray(sourceItems) || !sourceItems.length || !internalMax || internalMax <= 0) return 0;
  let sumPct = 0, n = 0;
  for (const it of sourceItems) {
    const rawMax = Number(it?.max ?? 0);
    if (!rawMax || rawMax <= 0) continue;               // skip invalid max
    const rawObt = Number(it?.obtained ?? 0);           // AB/missing => 0
    const pct = Math.max(0, Math.min(1, rawObt / rawMax));
    sumPct += pct;
    n += 1;                                             // include in average if max valid
  }
  if (!n) return 0;
  return Math.round((sumPct / n) * internalMax);        // integer only (e.g., 15), NOT "15/20"
}

             let marksPromises = students.map(stu =>
              db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
                .collection('classes').doc(currentClassId)
                .collection('sections').doc(currentSectionId)
                .collection('students').doc(stu.id)
                .collection('marks').doc(examId)
                .get().then(doc => {
                  if (!doc.exists) return;
                  const d = doc.data() || {};
                  console.log('DBG', stu.name, 'keys:', Object.keys(d), 'subsKeys:', d.__subs ? Object.keys(d.__subs) : []);
                  const totKey = Object.keys(d).find(k =>
                  k !== '__subs' && _normKey(k) === _normKey(subjectName)
                );
                if (totKey && d[totKey] !== undefined && totKey !== '__subs') {
                  marksData[stu.id] = d[totKey];
                }
                 if (hasSubs && d.__subs) {
  const want = _normKey(subjectName);
  const subjKey = Object.keys(d.__subs).find(k => _normKey(k) === want);
  if (subjKey) {
    breakdownData[stu.id] = d.__subs[subjKey] || {};
    console.log('DBG subs (exact) for', stu.name, 'â†’', subjKey, breakdownData[stu.id]);
  } else {
    console.log('DBG subs MISS (exact-only) for', stu.name, 'want:', subjectName);
  }
}
                  // Back-compat (exact-only): older writes ".__subs.<Subject>"
              if (hasSubs && (!d.__subs || !Object.keys(d.__subs).length)) {
                const wantFlat = `__subs.${subjectName}`;
                const flatKey = Object.keys(d).find(k => _normKey(k) === _normKey(wantFlat));
                if (flatKey && d[flatKey] && typeof d[flatKey] === 'object') {
                  breakdownData[stu.id] = d[flatKey];
                  console.log('DBG back-compat subs (exact) for', stu.name, 'â†’', flatKey, breakdownData[stu.id]);
                }
              }
                })
            );
            Promise.all(marksPromises).then(async () => {

  // ---- Build Internal prefill map (studentId -> integer) if Internal is configured ----
  // Detect "Internal" subtopic (computed:true) on this subject/exam
  const internalSt = Array.isArray(subtopics)
    ? subtopics.find(st => st && st.computed === true && (String(st.name || '').toLowerCase() === 'internal'))
    : null;

  // helper: for a given source exam id, get the subject max for this subject (from loaded exams list)
  function _getSourceSubjectMax(examId, subjectName) {
    const ex = exams.find(e => e.id === examId);
    if (!ex || !Array.isArray(ex.subjects)) return null;
    const s = ex.subjects.find(x => x && x.name === subjectName);
    return s ? Number(s.max) : null;
  }

  // Map: studentId -> integer internal marks
  const internalPrefill = {};

  if (internalSt && Array.isArray(internalSt.sources) && internalSt.sources.length && Number(internalSt.max) > 0) {
    const srcIds = internalSt.sources.slice();

    // Only keep sources that actually have a valid max for this subject
    const validSources = srcIds
      .map(id => ({ id, sMax: _getSourceSubjectMax(id, subjectName) }))
      .filter(x => x.sMax && x.sMax > 0);

    // For each student, fetch obtained marks from each valid source exam
    await Promise.all(students.map(async (stu) => {
      const items = [];
      for (const src of validSources) {
        try {
          const doc = await db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
            .collection('classes').doc(currentClassId)
            .collection('sections').doc(currentSectionId)
            .collection('students').doc(stu.id)
            .collection('marks').doc(src.id)
            .get();

          let obtained = 0;
          if (doc.exists) {
            const d = doc.data() || {};
            // read obtained for this subject (exact name match)
            const totKey = Object.keys(d).find(k => k !== '__subs' && _normKey(k) === _normKey(subjectName));
            if (totKey && d[totKey] != null) obtained = Number(d[totKey]) || 0;  // AB/missing => 0
          }
          items.push({ obtained, max: src.sMax });
        } catch (e) {
          // on read error, treat as absent (0)
          items.push({ obtained: 0, max: src.sMax });
        }
      }
      internalPrefill[stu.id] = _computeInternalFromArray(items, Number(internalSt.max));
    }));
  }

                         // Resolve grading scale once for this popup (exam â†’ school default â†’ legacy)
             const gradingScaleResolved = resolveScaleForExam(exam, await readSchoolGradingDefault());

             let html2 = `

                <form id="marksEntryForm" style="max-height:77vh;overflow-y:auto;">
                  <div class="popup-title">
                Marks: ${exam.name} â€“ ${subjectName} (Max: ${max})
                ${subj && subj.excludeFromTotal ? '<span style="color:#a15d00; font-weight:700; margin-left:6px;">[Optional â€“ not in total]</span>' : ''}
              </div>
                  <div style="display:flex;flex-direction:column;gap:8px;">
              
                    ${
                      students.length === 0
                        ? '<div style="color:#888;font-style:italic;">No students found.</div>'
                        : students.map(stu => {
                            // subtopics grid layout: [roll | label/name | input]
                              if (hasSubs) {
                                const totalPre = (marksData[stu.id] != null) ? marksData[stu.id] : '';
                              
                                return `
                                  <div class="marks-row"
                                       style="display:grid; grid-template-columns:42px 1fr 96px; column-gap:10px; row-gap:10px; align-items:center;">
                                    <div class="roll-cell"
                                         style="grid-column:1; text-align:right; color:#1762a7; font-weight:700;">
                                      ${stu.roll ? (stu.roll + '.') : ''}
                                    </div>
                                    <div class="name-cell"
                                         style="grid-column:2 / 4; color:#1762a7; font-weight:700;">
                                      ${stu.name}
                                    </div>
                              
                                    ${
                                      (subtopics || []).slice().sort((a,b)=>{
  const aInt = a && a.computed === true && String(a.name||'').toLowerCase()==='internal';
  const bInt = b && b.computed === true && String(b.name||'').toLowerCase()==='internal';
  return (bInt?1:0) - (aInt?1:0); // put "Internal" (computed) first
}).map(st => {
  const isInternal = (st && st.computed === true && String(st.name || '').toLowerCase() === 'internal');

  // Prefill value:
  // - Internal: from internalPrefill map (integer; only the number)
  // - Manual: from saved breakdown (if any)
  let pre = '';
  if (isInternal) {
    pre = internalPrefill[stu.id] != null ? internalPrefill[stu.id] : '';
  } else {
    const bd = breakdownData[stu.id] || {};
    if (Object.prototype.hasOwnProperty.call(bd, st.name) && bd[st.name] != null) {
      pre = bd[st.name];
    } else {
      const k = _resolveSubKeyExact(bd, st.name);
      if (k && bd[k] != null) pre = bd[k];
    }
  }

  // Render: Internal is read-only; manual is editable
  const common = `
    <div style="grid-column:1;">&nbsp;</div>
    <div class="sub-label"
         style="grid-column:2; color:#2e7d32; font-weight:600;">
      ${st.name}
    </div>
  `;

  if (isInternal) {
    return `
      ${common}
      <input type="number"
             class="marks-input sub-input"
             data-stu="${stu.id}"
             data-subname="${encodeURIComponent(st.name)}"
             step="1" min="0"
             value="${pre}"
             readonly tabindex="-1"
             style="grid-column:3; width:96px; text-align:right; background:#f5f5f5; color:#333;" />
    `;
  } else {
    return `
      ${common}
      <input type="number"
             class="marks-input sub-input"
             data-stu="${stu.id}"
             data-subname="${encodeURIComponent(st.name)}"
             step="0.01" min="0"
             value="${pre}"
             style="grid-column:3; width:96px; text-align:right;" />

    `;
  }
}).join('')
                                    }
                              
                                                                       <div style="grid-column:1;">&nbsp;</div>
                                    <div class="sub-label"
                                         style="grid-column:2; color:#c62828; font-weight:700;">
                                      Total
                                    </div>
                                    <input type="number"
                                           class="marks-input total-input"
                                           data-stu="${stu.id}"
                                           step="0.01" min="0" max="${max}"
                                           value="${totalPre}" readonly
                                           style="grid-column:3; width:96px; text-align:right;" />
                              
                                    <small class="total-hint" data-stu="${stu.id}"
                                           style="grid-column:2 / 4; color:#888;"></small>
                                    <small class="grade-pill" data-stu="${stu.id}"
                                           style="grid-column:2 / 4; color:#1762a7; font-weight:700;"></small>
                                  </div>
                                `;
                              }
                             // fallback: no subtopics â†’ single total input (original flow)
                                                       const soloPre = (marksData[stu.id] != null) ? marksData[stu.id] : '';
                            return `
                              <div class="marks-row">
                                <span class="roll-name">${stu.roll ? stu.roll + '. ' : ''}${stu.name}</span>
                                <input
                                  type="number"
                                  name="marks_${stu.id}"
                                  value="${soloPre}"
                                  min="0" max="${max}" step="1"
                                  class="marks-input"
                                />
                                <small class="grade-pill" data-stu="${stu.id}" style="margin-left:10px;color:#1762a7;font-weight:700;"></small>
                              </div>
                            `;
                          }).join('')
                    }
              
                  </div>
                  <div class="popup-btn-row" style="margin-top:12px;">
                    <button type="button" class="popup-cancel-btn">Cancel</button>
                    <button type="submit" class="popup-action-btn">Save</button>
                  </div>
                </form>
              `;
              showPopup(html2, 'marksEntryForm', function(ev) {
               ev.preventDefault();
            // Make sure we can query inside the popup
            const popupContent =
              document.getElementById('popupContent') ||
              document.querySelector('.popup .popup-content') ||
              document.querySelector('.popup') ||
              document;
               let batch = db.batch();

          students.forEach(stu => {
            const markRef = db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
              .collection('classes').doc(currentClassId)
              .collection('sections').doc(currentSectionId)
              .collection('students').doc(stu.id).collection('marks').doc(examId);
          
            // collect subtopic values
                  const subBoxes = popupContent.querySelectorAll(
        `.sub-input[data-stu="${stu.id}"], [data-stu="${stu.id}"][data-subname]`
      );
                  let subsMap = {};
            subBoxes.forEach(b => {
             const raw = (b.dataset?.subname ?? b.getAttribute('data-subname') ?? '').toString();
          const name = decodeURIComponent(raw).trim();
              const val  = parseFloat(b.value);
              if (name && !isNaN(val)) subsMap[name] = val;
            });
          
            // compute total
            const totalEl = popupContent.querySelector(`.total-input[data-stu="${stu.id}"]`);
            const totalVal = totalEl && totalEl.value !== '' ? parseFloat(totalEl.value) : NaN;
            // when there are NO subtopics, read the single input
            let soloVal = NaN;
            if (!hasSubs) {
              const soloEl = popupContent.querySelector(`input[name="marks_${stu.id}"]`);
              if (soloEl && soloEl.value !== '') soloVal = parseFloat(soloEl.value);
            }

            if (hasSubs) {
  // SUBTOPICS MODE
if (Object.keys(subsMap).length === 0 && (isNaN(totalVal) || !totalEl || totalEl.value === '')) {
  // nothing entered â†’ delete (use update for dotted path)
 batch.set(markRef, {
  [subjectName]: firebase.firestore.FieldValue.delete(),
  [`__subs.${subjectName}`]: firebase.firestore.FieldValue.delete()
}, { merge: true });

} else {
  const toSaveTotal = isNaN(totalVal) ? 0 : totalVal;
  // save total (merge)
  batch.set(markRef, { [subjectName]: toSaveTotal }, { merge: true });
  // force type reset, then set as map (works even if old value was an array)
if (subjectName) {
  batch.set(markRef, { __subs: { [subjectName]: firebase.firestore.FieldValue.delete() } }, { merge: true });
  batch.set(markRef, { __subs: { [subjectName]: subsMap } }, { merge: true });
}

}
} else {
  // NO SUBTOPICS (single input)
  if (isNaN(soloVal)) {
  batch.set(markRef, {
  [subjectName]: firebase.firestore.FieldValue.delete(),
  __subs: { [subjectName]: firebase.firestore.FieldValue.delete() }
}, { merge: true });

  } else {
  // save total
  batch.set(markRef, { [subjectName]: soloVal }, { merge: true });
  // clear any previous breakdown using update (dotted path)
 batch.set(markRef, {
  __subs: { [subjectName]: firebase.firestore.FieldValue.delete() }
}, { merge: true });
}
}
          });
                 batch.commit().then(() => {
                  alert("Marks saved successfully!");
                  closePopup();
                }).catch(error => alert("Error saving marks: " + error.message));
              });
              // Auto-sum per student (robust, with event delegation)
              {
                                               function recomputeFor(stuId) {
                  const boxes = popupContent.querySelectorAll(`.sub-input[data-stu="${stuId}"]`);
                  let sum = 0;
                  boxes.forEach(b => {
                    const v = parseFloat(b.value);
                    if (!isNaN(v)) sum += v;
                  });
              
                  const totalEl = popupContent.querySelector(`.total-input[data-stu="${stuId}"]`);
                  const hintEl  = popupContent.querySelector(`.total-hint[data-stu="${stuId}"]`);
                  const gradeEl = popupContent.querySelector(`.grade-pill[data-stu="${stuId}"]`);
              
                  if (totalEl) {
                    totalEl.value = boxes.length ? Number(sum.toFixed(2)) : '';
                    totalEl.style.borderColor = sum > max ? '#d43f3a' : '#bbb';
                  }
                  if (hintEl) {
                    if (sum > max) {
                      hintEl.textContent = `> Max ${max}`;
                      hintEl.style.color = '#d43f3a';
                    } else {
                      hintEl.textContent = '';
                      hintEl.style.color = '#888';
                    }
                  }
                  if (gradeEl) {
                    if (boxes.length && max > 0) {
                      const pct = Math.max(0, Math.min(100, (sum / max) * 100));
                      gradeEl.textContent = `Grade: ${gradeFromPercent(pct, gradingScaleResolved)}`;
                    } else {
                      gradeEl.textContent = '';
                    }
                  }
                }
              
                // One listener for all subtopic inputs (works well on mobile)
                popupContent.addEventListener('input', (e) => {
                  if (e.target && e.target.classList.contains('sub-input')) {
                    const sid = e.target.getAttribute('data-stu');
                    recomputeFor(sid);
                  }
                });
              
                // Initial compute after the DOM is painted
                setTimeout(() => { students.forEach(s => recomputeFor(s.id)); }, 0);
              }
            });
            // Auto-sum per student (after DOM fully painted)
          {
            const nextFrame = () => new Promise(r => requestAnimationFrame(r));
            (async () => {
              // wait 2 frames to ensure inputs are in the DOM
              await nextFrame(); 
              await nextFrame();
          
                                         function recomputeFor(stuId) {
                const boxes = popupContent.querySelectorAll(`.sub-input[data-stu="${stuId}"]`);
                let sum = 0;
                boxes.forEach(b => {
                  const v = parseFloat(b.value);
                  if (!isNaN(v)) sum += v;
                });
          
                const totalEl = popupContent.querySelector(`.total-input[data-stu="${stuId}"]`);
                const hintEl  = popupContent.querySelector(`.total-hint[data-stu="${stuId}"]`);
                const gradeEl = popupContent.querySelector(`.grade-pill[data-stu="${stuId}"]`);
          
                if (totalEl) {
                  totalEl.value = boxes.length ? Number(sum.toFixed(2)) : '';
                  totalEl.style.borderColor = sum > max ? '#d43f3a' : '#bbb';
                }
                if (hintEl) {
                  if (sum > max) { 
                    hintEl.textContent = `> Max ${max}`;
                    hintEl.style.color = '#d43f3a';
                  } else {
                    hintEl.textContent = '';
                    hintEl.style.color = '#888';
                  }
                }
                if (gradeEl) {
                  if (boxes.length && max > 0) {
                    const pct = Math.max(0, Math.min(100, (sum / max) * 100));
                    gradeEl.textContent = `Grade: ${gradeFromPercent(pct, gradingScaleResolved)}`;
                  } else {
                    gradeEl.textContent = '';
                  }
                }
              }
          
              // attach multiple event types for reliability on mobile
                            popupContent.querySelectorAll('.sub-input').forEach(inp => {
                const sid = inp.getAttribute('data-stu');
                ['input','change','keyup','blur'].forEach(evt =>
                  inp.addEventListener(evt, () => recomputeFor(sid))
                );
              });
              // also recompute grade in single-total (no subtopics) rows
              popupContent.querySelectorAll('input[name^="marks_"]').forEach(inp => {
                const sid = inp.name.replace('marks_', '');
                const gradeEl = popupContent.querySelector(`.grade-pill[data-stu="${sid}"]`);
                                const updateSolo = () => {
                  const v = parseFloat(inp.value);
                  if (!isNaN(v) && max > 0) {
                    const pct = Math.max(0, Math.min(100, (v / max) * 100));
                    if (gradeEl) gradeEl.textContent = `Grade: ${gradeFromPercent(pct, gradingScaleResolved)}`;
                  } else if (gradeEl) {
                    gradeEl.textContent = '';
                  }
                };
                ['input','change','keyup','blur'].forEach(evt => inp.addEventListener(evt, updateSolo));
                // initial
                updateSolo();
              });
          
                            // initial compute (prefilled values)
              students.forEach(s => recomputeFor(s.id));
              // also initialize solo rows (no subtopics)
              popupContent.querySelectorAll('input[name^="marks_"]').forEach(inp => {
                const ev = new Event('input');
                inp.dispatchEvent(ev);
              });
            })();
          }
          });
      });

      // ======= Custom Dropdown Logic for Exam =======
      const examDropdown = document.getElementById('examDropdown');
      const examSelected = document.getElementById('examSelected');
      const examList = document.getElementById('examList');
      const subjectDropdown = document.getElementById('subjectDropdown');
      const subjectSelected = document.getElementById('subjectSelected');
      const subjectList = document.getElementById('subjectList');
      let selectedExam = null;

      // Populate exam dropdown
      examList.innerHTML = exams.map(e => `
        <div class="dropdown-option" data-id="${e.id}" style="padding:10px 12px;cursor:pointer;">
          ${e.name}
        </div>
      `).join('');

      // Exam show/hide
      examSelected.onclick = function () {
        examList.style.display = (examList.style.display === 'none' || examList.style.display === '') ? 'block' : 'none';
      };
      document.addEventListener('click', function handler(e) {
        if (!examDropdown.contains(e.target)) {
          examList.style.display = 'none';
          document.removeEventListener('click', handler);
        }
      });

      // Exam select logic
      examList.querySelectorAll('.dropdown-option').forEach(opt => {
        opt.onclick = function () {
          examSelected.textContent = this.textContent;
          examSelected.dataset.value = this.dataset.id;
          examList.style.display = 'none';
          // Fill subject dropdown
          const ex = exams.find(e => e.id === this.dataset.id);
          selectedExam = ex;
          if (ex && Array.isArray(ex.subjects) && ex.subjects.length > 0) {
            subjectList.innerHTML = ex.subjects.map(s => `<div class="dropdown-option" data-name="${s.name}">${s.name} (Max: ${s.max})</div>`).join('');
            subjectSelected.textContent = '--Select--';
            subjectSelected.dataset.value = '';
            subjectSelected.classList.remove('disabled');
            subjectList.style.display = 'none';
            subjectSelected.style.pointerEvents = '';
          } else {
            subjectList.innerHTML = `<div class="dropdown-option" data-name="">No subjects</div>`;
            subjectSelected.textContent = 'No subjects';
            subjectSelected.dataset.value = '';
            subjectSelected.classList.add('disabled');
            subjectList.style.display = 'none';
            subjectSelected.style.pointerEvents = 'none';
          }
        };
      });

      // Subject show/hide
      subjectSelected.onclick = function () {
        if (!selectedExam || !selectedExam.subjects || !selectedExam.subjects.length) return;
        subjectList.style.display = (subjectList.style.display === 'none' || subjectList.style.display === '') ? 'block' : 'none';
      };
      document.addEventListener('click', function handler(e) {
        if (!subjectDropdown.contains(e.target)) {
          subjectList.style.display = 'none';
          document.removeEventListener('click', handler);
        }
      });

      // Subject select logic
      subjectList.addEventListener('click', function (e) {
        if (e.target.classList.contains('dropdown-option')) {
          subjectSelected.textContent = e.target.textContent;
          subjectSelected.dataset.value = e.target.dataset.name;
          subjectList.style.display = 'none';
        }
      });
    });
}
    // ========== ATTENDANCE + WHATSAPP ===========
    function showAttendancePopup() {
        db.collection('schools').doc(schoolId).collection('years').doc(academicYear).collection('classes').doc(currentClassId)
          .collection('sections').doc(currentSectionId)
          .collection('students').orderBy('roll').get()
          .then(snap => {
            let students = [];
            snap.forEach(doc => { if (!doc.data().isDeleted) students.push({ id: doc.id, ...doc.data() }); });
            // Add: Date selection field, default today
            let today = new Date().toISOString().slice(0, 10);
            let html = `
              <form id="attendanceDateForm">
                <div class="popup-title">Select Date for Attendance</div>
                <label for="attendanceDate">Attendance Date</label>
                <input type="date" id="attendanceDate" name="attendanceDate" value="${today}" max="${today}" required style="font-size:1.13em;margin-bottom:10px;">
                <div class="popup-btn-row" style="margin-top:6px;">
                  <button type="button" class="popup-cancel-btn">Cancel</button>
                  <button type="submit" class="popup-action-btn">Next</button>
                </div>
              </form>
            `;
            showPopup(html, 'attendanceDateForm', function(e){
              e.preventDefault();
              let date = e.target.attendanceDate.value;
              if (!date) return;
              // Now show actual attendance form for that date
              showAttendanceEntryForDate(date, students);
            });
          });
      }
      
      // Helper: actual attendance entry UI for a given date
      function showAttendanceEntryForDate(date, students) {
        db.collection('schools').doc(schoolId).collection('years').doc(academicYear).collection('classes').doc(currentClassId)
          .collection('sections').doc(currentSectionId)
          .collection('attendance').doc(date)
          .get()
          .then(attSnap => {
          let attData = attSnap.exists ? attSnap.data() : {};
          let html = `
          <form id="attendanceForm">
            <div class="popup-title">Take Attendance - ${date}</div>
            <div style="max-height:270px;overflow-y:auto;">
               ${students.map(stu => {
                let mChecked = attData[stu.id]?.M === 'absent' ? 'checked' : '';
                let aChecked = attData[stu.id]?.A === 'absent' ? 'checked' : '';
                return `
                  <div style="display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 8px 0; border-bottom: 1px solid #f3f3f3;">
                  <div style="display: flex; align-items: center; gap: 6px; min-width: 0;">
                    <span style="width:32px; font-weight:600; color:#1762a7; text-align:right;">
                      ${stu.roll ? stu.roll + '.' : ''}
                    </span>
                    <span style="color:#1762a7; font-weight:600; font-size:1.07em; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">
                      ${stu.name}
                    </span>
                  </div>
                  <div style="display:flex;align-items:center;gap:12px;">
                    <!-- Attendance M/A boxes, right aligned, label above each box -->
                    <div style="display:flex;flex-direction:column;align-items:flex-end;gap:4px;">
                      <div style="display:flex;gap:16px;margin-bottom:2px;">
                        <span style="font-size:0.97em;font-weight:600;text-align:center;width:26px;">M</span>
                        <span style="font-size:0.97em;font-weight:600;text-align:center;width:26px;">A</span>
                      </div>
                      <div style="display:flex;gap:16px;">
                        <span class="att-box" data-type="M" data-stu="${stu.id}" style="width:26px;height:26px;display:flex;align-items:center;justify-content:center;border:1.7px solid #0f3d6b;border-radius:6px;cursor:pointer;font-size:1.18em;background:#fff;color:#0f3d6b;"></span>
                        <span class="att-box" data-type="A" data-stu="${stu.id}" style="width:26px;height:26px;display:flex;align-items:center;justify-content:center;border:1.7px solid #0f3d6b;border-radius:6px;cursor:pointer;font-size:1.18em;background:#fff;color:#0f3d6b;"></span>
                      </div>
                    </div>
                    ${
                      stu.parentPhone
                      ? `<button type="button" class="wa-btn" data-ph="${stu.parentPhone}" data-name="${stu.name}" data-stuid="${stu.id}" style="background:#25D366; width:34px; height:34px; display:none; align-items:center; justify-content:center; border-radius:50%; border:none; padding:0;">
                            <svg viewBox="0 0 32 32" width="21" height="21">
                              <circle cx="16" cy="16" r="16" fill="#25D366"/>
                              <path fill="#fff" d="M21.6,17.9c-0.3-0.2-1.9-0.9-2.2-1c-0.3-0.1-0.5-0.2-0.7,0.2c-0.2,0.3-0.7,1-0.8,1.2
                                c-0.1,0.2-0.3,0.3-0.6,0.1c-0.3-0.2-1.3-0.5-2.4-1.6c-0.9-0.9-1.5-1.9-1.7-2.2c-0.2-0.3,0-0.5,0.2-0.7c0.2-0.2,0.3-0.4,0.5-0.6
                                c0.2-0.2,0.2-0.3,0.3-0.5c0.1-0.2,0-0.4,0-0.6c0-0.2-0.7-1.8-1-2.5c-0.2-0.6-0.4-0.5-0.6-0.5c-0.2,0-0.4,0-0.7,0
                                c-0.2,0-0.5,0.1-0.8,0.4c-0.2,0.3-1,1-1,2.4c0,1.3,1,2.6,1.2,2.8c0.2,0.3,2,3.2,4.9,4.4c0.7,0.3,1.2,0.4,1.7,0.6
                                c0.7,0.2,1.3,0.2,1.8,0.1c0.5-0.1,1.6-0.7,1.8-1.3c0.2-0.6,0.2-1.2,0.1-1.3C22,18.1,21.9,18.1,21.6,17.9z"/>
                              <path fill="#fff" d="M16,6C10,6,5,11,5,17c0,2.1,0.6,4.1,1.7,5.8L5,27l4.3-1.4C11.9,26.4,13.9,27,16,27c6,0,11-5,11-11S22,6,16,6z
                                M16,25c-1.8,0-3.5-0.4-5.1-1.2l-0.4-0.2l-2.6,0.9l0.9-2.6l-0.2-0.4C7.4,19.5,7,18.3,7,17c0-5,4-9,9-9s9,4,9,9S21,25,16,25z"/>
                            </svg>
                        </button>`
                      : ''
                    }
                  </div>
                </div>
                `;
              }).join('')}
            </div>
            <div class="popup-btn-row" style="margin-top:16px;">
              <button type="button" class="popup-cancel-btn">Cancel</button>
              <button type="submit" class="popup-action-btn">Save Attendance</button>
            </div>
          </form>
          <div style="font-size:0.95em;color:#387c23;margin-top:8px;">
            Tick M for Morning Absentees, A for Afternoon. WhatsApp will message parent.
          </div>
          `;
         showPopup(html, 'attendanceForm', function(e){
          e.preventDefault();
          let form = e.target;
          let attObj = {};
          let absentees = [];
          students.forEach(stu => {
            let mBox = popupContent.querySelector(`.att-box[data-stu="${stu.id}"][data-type="M"]`);
            let aBox = popupContent.querySelector(`.att-box[data-stu="${stu.id}"][data-type="A"]`);
            let m = (mBox && mBox.textContent === 'a') ? 'absent' : 'present';
            let a = (aBox && aBox.textContent === 'a') ? 'absent' : 'present';
            attObj[stu.id] = { M: m, A: a };
            if (m === 'absent' || a === 'absent') {
              absentees.push({
                roll: stu.roll,
                name: stu.name,
                absentM: m === 'absent',
                absentA: a === 'absent'
              });
            }
          });
        
          // If any absentees, show confirmation
          if (absentees.length > 0) {
            let absentHtml = `
              <div class="popup-title">Confirm Absentees</div>
              <div style="max-height:240px;overflow-y:auto;">
                <table style="width:100%;border-collapse:collapse;">
                  <tr style="font-weight:bold;">
                    <td style="border-bottom:1px solid #eee;">Roll</td>
                    <td style="border-bottom:1px solid #eee;">Name</td>
                    <td style="border-bottom:1px solid #eee;">Session</td>
                  </tr>
                  ${
                    absentees.map(stu =>
                      `<tr>
                        <td>${stu.roll || ''}</td>
                        <td>${stu.name}</td>
                        <td>
                          ${stu.absentM ? 'M' : ''}${(stu.absentM && stu.absentA) ? '/' : ''}${stu.absentA ? 'A' : ''}
                        </td>
                      </tr>`
                    ).join('')
                  }
                </table>
                <div style="margin:16px 0;color:#d43f3a;">Are you sure you want to mark these students as absent?</div>
              </div>
              <div class="popup-btn-row">
                <button type="button" class="popup-cancel-btn">No, Go Back</button>
                <button type="button" class="popup-action-btn" id="confirmSaveAttendanceBtn">Yes, Save</button>
              </div>
            `;
           showPopup(absentHtml);
          setTimeout(() => {
            let btn = popupContent.querySelector('#confirmSaveAttendanceBtn');
            if (btn) btn.onclick = function() {
              let attDoc = db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
                .collection('classes').doc(currentClassId)
                .collection('sections').doc(currentSectionId)
                .collection('attendance').doc(date);
              attDoc.set(attObj).then(() => {
                alert("Attendance saved!");
                closePopup();
              });
            }
            // Replace default cancel handler to "go back" to marking
            let cancelBtn = popupContent.querySelector('.popup-cancel-btn');
            if (cancelBtn) cancelBtn.onclick = function() {
              showAttendanceEntryForDate(date, students); // Go back to marking popup!
            }
          }, 120);
          } else {
            // No absentees, just save
            let attDoc = db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
              .collection('classes').doc(currentClassId)
              .collection('sections').doc(currentSectionId)
              .collection('attendance').doc(date);
            attDoc.set(attObj).then(() => {
              alert("Attendance saved!");
              closePopup();
            });
          }
        });
    
    // --- Clickable attendance boxes ("a" toggle) and WhatsApp logic ---
    setTimeout(() => {
      // Make each .att-box clickable
      popupContent.querySelectorAll('.att-box').forEach(box => {
        box.onclick = function() {
          // Toggle "a" when clicked
          if (box.textContent === 'a') {
            box.textContent = '';
            box.style.color = '#0f3d6b';
          } else {
            box.textContent = 'a';
            box.style.color = '#d43f3a';
            box.style.fontWeight = 'bold';
          }
    
          // Show/hide WhatsApp button for this row
          let row = box.closest('div[style*="display: flex"]');
          if (!row) return;
          let mBox = row.querySelector('.att-box[data-type="M"]');
          let aBox = row.querySelector('.att-box[data-type="A"]');
          let waBtn = row.querySelector('.wa-btn');
          if (waBtn) {
            if ((mBox && mBox.textContent === 'a') || (aBox && aBox.textContent === 'a')) {
              waBtn.style.display = 'flex';
            } else {
              waBtn.style.display = 'none';
            }
          }
        };
      });
    
      // Set "a" initially if the student is absent
      popupContent.querySelectorAll('.att-box').forEach(box => {
        let stuId = box.dataset.stu, type = box.dataset.type;
        if (attData[stuId]?.[type] === 'absent') {
          box.textContent = 'a';
          box.style.color = '#d43f3a';
          box.style.fontWeight = 'bold';
        } else {
          box.textContent = '';
          box.style.color = '#0f3d6b';
          box.style.fontWeight = 'bold';
        }
      });
    
      // Show/hide WhatsApp icon initially
      students.forEach(stu => {
        let row = popupContent.querySelector(`.att-box[data-stu="${stu.id}"]`)?.closest('div[style*="display: flex"]');
        if (!row) return;
        let mBox = row.querySelector('.att-box[data-type="M"]');
        let aBox = row.querySelector('.att-box[data-type="A"]');
        let waBtn = row.querySelector('.wa-btn');
        if (waBtn) {
          if ((mBox && mBox.textContent === 'a') || (aBox && aBox.textContent === 'a')) {
            waBtn.style.display = 'flex';
          } else {
            waBtn.style.display = 'none';
          }
        }
      });
    }, 250);

 // WhatsApp button event (unchanged)
          setTimeout(() => {
            popupContent.querySelectorAll('.wa-btn').forEach(btn => {
              btn.onclick = async function() {
  let ph = btn.dataset.ph.replace(/^0+/, '');
  let name = btn.dataset.name;
  let stuid = btn.dataset.stuid;

  // Fetch all attendance records for this section to count absents
  let attSnap = await db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
    .collection('classes').doc(currentClassId)
    .collection('sections').doc(currentSectionId)
    .collection('attendance').get();

  let daysAbsent = 0;
  attSnap.forEach(doc => {
    let data = doc.data()[stuid];
    if (data) {
      let absentM = data.M === 'absent';
      let absentA = data.A === 'absent';
      if (absentM && absentA) {
        daysAbsent += 1;      // full day
      } else if (absentM || absentA) {
        daysAbsent += 0.5;    // half day
      }
    }
  });

  let daysAbsentStr = (Math.round(daysAbsent * 10) / 10).toString();

  let msg = encodeURIComponent(
  `*Dear Parent,*\n\n` +
  `Your child *${name}* is absent today at school. Kindly send reason for absence. *${name}* has been absent for ${daysAbsentStr} day(s) so far this academic year.\n\n` + 
  `*${name}* à°ˆ à°°à±‹à°œà± à°¸à±à°•à±‚à°²à±â€Œà°•à± à°¹à°¾à°œà°°à± à°•à°¾à°²à±‡à°¦à±. à°¹à°¾à°œà°°à± à°•à°¾à°•à°ªà±‹à°µà°¡à°¾à°¨à°¿à°•à°¿ à°—à°² à°•à°¾à°°à°£à°‚ à°¤à±†à°²à°¿à°¯à°œà±‡à°¯à°—à°²à°°à±. à°‡à°ªà±à°ªà°Ÿà°¿ à°µà°°à°•à± à°®à±Šà°¤à±à°¤à°‚ ${daysAbsentStr} à°°à±‹à°œà±à°²à± à°…à°¬à±à°¸à±†à°‚à°Ÿà± à°…à°¯à±à°¯à°¾à°°à±.\n\n` +
  `Thank you\n` +
  `*St. Patrick's School*`
);
  window.open(`https://wa.me/91${ph}?text=${msg}`,'_blank');
}

            });
          }, 400);
    });
}
    function showAttendanceHistoryPopup() {
  // Get attendance docs for this section
  db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
    .collection('classes').doc(currentClassId)
    .collection('sections').doc(currentSectionId)
    .collection('attendance').orderBy(firebase.firestore.FieldPath.documentId()).get()
    .then(snap => {
      if (snap.empty) {
        showPopup(`<div class="popup-title">Attendance History</div>
          <div style="color:#888;">No attendance records found.</div>
          <div class="popup-btn-row"><button class="popup-cancel-btn">Close</button></div>
        `);
        return;
      }
     let dates = [];
        snap.forEach(doc => dates.push(doc.id));
        
        // Extract unique years and months
        let monthsSet = new Set(), yearsSet = new Set();
        dates.forEach(d => {
          let [y, m] = d.split('-');
          yearsSet.add(y);
          monthsSet.add(m);
        });
        let months = Array.from(monthsSet).sort();
        let years = Array.from(yearsSet).sort();
        let today = new Date();
        let defaultYear = today.getFullYear().toString();
        let defaultMonth = (today.getMonth() + 1).toString().padStart(2, '0');
        
        // Initial selected month/year
        let selectedYear = defaultYear;
        let selectedMonth = defaultMonth;
        
        // Build selects
        function buildMonthYearDropdown(selectedMonth, selectedYear) {
  return `
    <div style="display:flex;gap:10px;align-items:center;margin-bottom:12px;">
      <!-- Month Dropdown -->
      <div class="custom-dropdown" id="monthDropdown">
        <div class="dropdown-selected" id="monthSelected">${monthName(selectedMonth)}</div>
        <div class="dropdown-list" id="monthList" style="display:none;">
          ${months.map(m => `<div class="dropdown-option" data-value="${m}">${monthName(m)}</div>`).join('')}
        </div>
      </div>
      <!-- Year Dropdown -->
      <div class="custom-dropdown" id="yearDropdown">
        <div class="dropdown-selected" id="yearSelected">${selectedYear}</div>
        <div class="dropdown-list" id="yearList" style="display:none;">
          ${years.map(y => `<div class="dropdown-option" data-value="${y}">${y}</div>`).join('')}
        </div>
      </div>
    </div>
  `;
}

        function monthName(m) {
          return ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][parseInt(m)-1];
        }
        
        // Function to filter and show dates
        function showFilteredDates(selectedMonth, selectedYear) {
          let filteredDates = dates.filter(d => d.startsWith(selectedYear + '-' + selectedMonth));
          filteredDates.sort((a, b) => b.localeCompare(a));
          let listHtml = filteredDates.length === 0
            ? `<div style="color:#888;padding:14px 0;text-align:center;">No attendance found for this month.</div>`
            : filteredDates.map(date => `<button class="popup-action-btn" data-date="${date}" style="padding:8px 12px;font-size:1em;">${formatDate(date)}</button>`).join('');
          popupContent.querySelector('#datesList').innerHTML = listHtml;
        
          // --- ADD THIS: attach click event for new date buttons ---
          popupContent.querySelectorAll('.popup-action-btn[data-date]').forEach(btn => {
            btn.onclick = () => showAttendanceForDate(btn.dataset.date);
          });
        }
         // Initial HTML
        let html = `
          <div class="popup-title">Attendance Dates</div>
          ${buildMonthYearDropdown(selectedMonth, selectedYear)}
          <button id="downloadExcelBtn" style="margin-bottom:10px;padding:6px 16px;background:#2b8e32;color:#fff;border:none;border-radius:6px;float:right;">Download Excel</button>
          <div id="datesList" style="clear:both;max-height:269px;overflow-y:auto;display:flex;flex-direction:column;gap:8px;margin-bottom:10px;"></div>
          <div class="popup-btn-row"><button class="popup-cancel-btn">close</button></div>
        `;
          showPopup(html);
          setTimeout(() => {
            const excelBtn = document.getElementById('downloadExcelBtn');
          if (!excelBtn) return;
          excelBtn.onclick = async function () {
            // Get month & year from selectors
            const month = (() => {
            const m = popupContent.querySelector('#monthSelected');
            return m && m.textContent ? months.find(mm => monthName(mm) === m.textContent) : '';
          })();
          const year = (() => {
            const y = popupContent.querySelector('#yearSelected');
            return y && y.textContent ? y.textContent : '';
          })();
            // Get all students
            let stuSnap = await db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
              .collection('classes').doc(currentClassId)
              .collection('sections').doc(currentSectionId)
              .collection('students').orderBy('roll').get();
            let students = [];
            stuSnap.forEach(doc => students.push({ id: doc.id, ...doc.data() }));
          
            // Get all attendance docs
            let attSnap = await db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
              .collection('classes').doc(currentClassId)
              .collection('sections').doc(currentSectionId)
              .collection('attendance').get();
          
            // Filter attendance by selected month, get unique dates sorted
            let days = [];
            attSnap.forEach(doc => {
              let d = doc.id; // "YYYY-MM-DD"
              if (d.startsWith(`${year}-${month}`)) days.push(d);
            });
            days.sort();
          
            // Build headers for date/M/A
            let titleRow = [`${currentClassName} ${currentSectionName} (Jun ${year})`];
            // Merge this cell across columns in Excel
            let headerRow = ['Roll', 'Name'];
            let subHeaderRow = ['', ''];
            days.forEach(d => {
              let dayNum = d.split('-')[2];
              headerRow.push(dayNum, '');
              subHeaderRow.push('M', 'A');
            });
          
            // Prepare data rows
            let data = [titleRow, headerRow, subHeaderRow];
            students.forEach(stu => {
              let row = [stu.roll, stu.name];
              days.forEach(d => {
                // Default to present if attendance not found
                let attData = attSnap.docs.find(doc => doc.id === d)?.data() || {};
                let statusM = attData[stu.id]?.M === 'absent' ? 'Ab' : 'X';
                let statusA = attData[stu.id]?.A === 'absent' ? 'Ab' : 'X';
                row.push(statusM, statusA);
              });
              data.push(row);
            });
          
            // Export to Excel (SheetJS community)
            let ws = XLSX.utils.aoa_to_sheet(data);
            // Merge the top row
            ws['!merges'] = [{s:{r:0,c:0}, e:{r:0,c:headerRow.length-1}}];
            // Set compact column width
            ws['!cols'] = [{ wch: 5 }, { wch: 18 }, ...Array(days.length * 2).fill({ wch: 3 })];
          
            let wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "Attendance");
            XLSX.writeFile(wb, `Attendance_${year}-${month}_${currentSectionName}.xlsx`);
          };
          }, 500);
                  
        // Initial render
        showFilteredDates(selectedMonth, selectedYear);
        
        // Add change listeners for custom dropdowns
setTimeout(() => {
  // MONTH DROPDOWN
  const monthDropdown = popupContent.querySelector('#monthDropdown');
  const monthSelected = popupContent.querySelector('#monthSelected');
  const monthList = popupContent.querySelector('#monthList');
  if (monthDropdown && monthSelected && monthList) {
    monthSelected.onclick = function () {
      monthList.style.display = monthList.style.display === 'block' ? 'none' : 'block';
    };
    monthList.querySelectorAll('.dropdown-option').forEach(opt => {
      opt.onclick = function () {
        monthSelected.textContent = this.textContent;
        selectedMonth = this.dataset.value;
        monthList.style.display = 'none';
        showFilteredDates(selectedMonth, selectedYear);
      }
    });
    document.addEventListener('click', function handler(e){
      if (!monthDropdown.contains(e.target)) monthList.style.display = 'none';
    });
  }

  // YEAR DROPDOWN
  const yearDropdown = popupContent.querySelector('#yearDropdown');
  const yearSelected = popupContent.querySelector('#yearSelected');
  const yearList = popupContent.querySelector('#yearList');
  if (yearDropdown && yearSelected && yearList) {
    yearSelected.onclick = function () {
      yearList.style.display = yearList.style.display === 'block' ? 'none' : 'block';
    };
    yearList.querySelectorAll('.dropdown-option').forEach(opt => {
      opt.onclick = function () {
        yearSelected.textContent = this.textContent;
        selectedYear = this.dataset.value;
        yearList.style.display = 'none';
        showFilteredDates(selectedMonth, selectedYear);
      }
    });
    document.addEventListener('click', function handler(e){
      if (!yearDropdown.contains(e.target)) yearList.style.display = 'none';
    });
  }

  // Button click to show that day's attendance
  popupContent.querySelectorAll('.popup-action-btn[data-date]').forEach(btn => {
    btn.onclick = () => showAttendanceForDate(btn.dataset.date);
  });
}, 200);
        
        // Utility
        function formatDate(dateStr) {
          if (!dateStr) return '';
          const [y, m, d] = dateStr.split('-');
          return `${d}-${m}-${y}`;
        }
         // Add event handlers for each date button
      setTimeout(() => {
        popupContent.querySelectorAll('button[data-date]').forEach(btn => {
          btn.onclick = function() {
            showAttendanceForDate(this.getAttribute('data-date'));
          }
        });
      }, 100);
    });
}
function showDeletedStudentsPopup() {
  db.collection('schools').doc(schoolId).collection('years').doc(academicYear).collection('classes').doc(currentClassId)
    .collection('sections').doc(currentSectionId)
    .collection('students').orderBy('roll').get()
    .then(snap => {
      let students = [];
snap.forEach(doc => {
  let data = doc.data();
  // Accepts true, "true", or 1 as deleted (for safety)
  if (data.isDeleted === true || data.isDeleted === "true" || data.isDeleted === 1) {
    students.push({ id: doc.id, ...data });
  }
});
let html = `
  <div class="popup-title">Deleted Students</div>
        <div style="max-height:350px;overflow-y:auto;">
          ${
            students.length === 0
              ? `<div style="color:#888;text-align:center;">No deleted students.</div>`
              : students.map(stu => `
                <div style="padding: 14px 0; border-bottom: 1px solid #f3f3f3;">
                  <div style="font-weight:bold; font-size:1.12em; margin-bottom: 6px; text-align:left;">
                    <span style="color:#d43f3a;">${stu.roll ? stu.roll + '. ' : ''}${stu.name}</span>
                  </div>
                  <div style="display:flex; gap:16px; justify-content:center;">
                    <button class="popup-action-btn" style="background:#26bb5a; min-width:115px;" data-restore="${stu.id}">Restore</button>
                    <button class="popup-action-btn" style="background:#d43f3a; min-width:160px;" data-delete="${stu.id}">Delete Permanently</button>
                  </div>
                </div>
              `).join('')
          }
        </div>
        <div class="popup-btn-row"><button class="popup-cancel-btn">Close</button></div>
      `;
      showPopup(html);

      // Attach restore handlers
      popupContent.querySelectorAll('button[data-restore]').forEach(btn => {
        btn.onclick = function() {
          const id = btn.getAttribute('data-restore');
          db.collection('schools').doc(schoolId).collection('years').doc(academicYear).collection('classes').doc(currentClassId)
            .collection('sections').doc(currentSectionId)
            .collection('students').doc(id)
            .update({ isDeleted: firebase.firestore.FieldValue.delete() })
            .then(() => {
              showDeletedStudentsPopup(); // Refresh the list
              renderStudentList(); // Refresh main list if open
            });
        }
      });
      // Attach permanent delete handlers
      popupContent.querySelectorAll('button[data-delete]').forEach(btn => {
        btn.onclick = function() {
          const id = btn.getAttribute('data-delete');
          if (!confirm("Are you sure you want to permanently delete this student? This cannot be undone!")) return;
          db.collection('schools').doc(schoolId).collection('years').doc(academicYear).collection('classes').doc(currentClassId)
            .collection('sections').doc(currentSectionId)
            .collection('students').doc(id)
            .delete()
            .then(() => {
              showDeletedStudentsPopup(); // Refresh the list
              renderStudentList(); // Refresh main list if open
            });
        }
      });
    });
}
// View attendance for one date
function showAttendanceForDate(date) {
  // Load student list
  db.collection('schools').doc(schoolId).collection('years').doc(academicYear).collection('classes').doc(currentClassId)
    .collection('sections').doc(currentSectionId).collection('students').orderBy('roll').get()
    .then(stuSnap => {
      let students = [];
      stuSnap.forEach(doc => students.push({ id: doc.id, ...doc.data() }));

      // Load all attendance docs for absence counts
      db.collection('schools').doc(schoolId).collection('years').doc(academicYear).collection('classes').doc(currentClassId)
        .collection('sections').doc(currentSectionId).collection('attendance').get()
        .then(allAttSnap => {
          let attDataByDate = {};
          let totalDays = 0;
          allAttSnap.forEach(d => {
            attDataByDate[d.id] = d.data();
            totalDays++;
          });

          // Load this dateâ€™s attendance
          db.collection('schools').doc(schoolId).collection('years').doc(academicYear).collection('classes').doc(currentClassId)
            .collection('sections').doc(currentSectionId).collection('attendance').doc(date).get()
            .then(attSnap => {
              let att = attSnap.data() || {};

              let html = `<div class="popup-title">Attendance: ${formatDate(date)}</div>
                <div style="max-height:290px;overflow-y:auto;">`;

              students.forEach(stu => {
  let daysAbsent = 0;
  let totalDays = Object.keys(attDataByDate).length;
  for (let d in attDataByDate) {
    let st = attDataByDate[d][stu.id] || {};
    const absentM = st.M === 'absent';
    const absentA = st.A === 'absent';
    if (absentM && absentA) {
      daysAbsent += 1;           // Full day absent
    } else if (absentM || absentA) {
      daysAbsent += 0.5;         // Half day absent
    }
  }
  // Format daysAbsent to show .5 if needed, else as integer
  let daysAbsentStr = daysAbsent % 1 === 0 ? daysAbsent.toString() : daysAbsent.toFixed(1);

  let stat = att[stu.id] || {};
  let statM = (stat.M || 'present').toLowerCase();
  let statA = (stat.A || 'present').toLowerCase();
  let badgeM = `<span class="att-badge att-m-${statM}">M: ${statM === 'absent' ? 'Ab' : 'Pr'}</span>`;
  let badgeA = `<span class="att-badge att-a-${statA}">A: ${statA === 'absent' ? 'Ab' : 'Pr'}</span>`;
  let totalBox = `<span class="att-total-box">${daysAbsentStr} / ${totalDays}</span>`;
  html += `
    <div class="att-row">
      <div class="att-main">
        <span class="att-name">${stu.roll ? stu.roll + '. ' : ''}${stu.name}</span>
        <div class="att-badges">
          ${badgeM}
          ${badgeA}
        </div>
      </div>
      ${totalBox}
    </div>
  `;
});
              html += `</div>
                <div class="popup-btn-row"><button class="popup-cancel-btn">Close</button></div>
              `;
              showPopup(html);
              // --- Modern Dropdown JS for Month & Year (Attendance History) ---
              setTimeout(() => {
                // MONTH DROPDOWN
                const monthDropdown = popupContent.querySelector('#monthDropdown');
                const monthSelected = popupContent.querySelector('#monthSelected');
                const monthList = popupContent.querySelector('#monthList');
                if(monthDropdown) {
                  monthSelected.onclick = function () {
                    monthList.style.display = monthList.style.display === 'block' ? 'none' : 'block';
                  };
                  monthList.querySelectorAll('.dropdown-option').forEach(opt => {
                    opt.onclick = function () {
                      monthSelected.textContent = this.textContent;
                      selectedMonth = this.dataset.value;
                      monthList.style.display = 'none';
                      showFilteredDates(selectedMonth, selectedYear);
                    }
                  });
                  document.addEventListener('click', function handler(e){
                    if (!monthDropdown.contains(e.target)) monthList.style.display = 'none';
                  });
                }
                // YEAR DROPDOWN
                const yearDropdown = popupContent.querySelector('#yearDropdown');
                const yearSelected = popupContent.querySelector('#yearSelected');
                const yearList = popupContent.querySelector('#yearList');
                if(yearDropdown) {
                  yearSelected.onclick = function () {
                    yearList.style.display = yearList.style.display === 'block' ? 'none' : 'block';
                  };
                  yearList.querySelectorAll('.dropdown-option').forEach(opt => {
                    opt.onclick = function () {
                      yearSelected.textContent = this.textContent;
                      selectedYear = this.dataset.value;
                      yearList.style.display = 'none';
                      showFilteredDates(selectedMonth, selectedYear);
                    }
                  });
                  document.addEventListener('click', function handler(e){
                    if (!yearDropdown.contains(e.target)) yearList.style.display = 'none';
                  });
                }
              }, 300);
            });
        });
    });
}
// Helper to show date as DD-MM-YYYY
function formatDate(dateStr) {
  if (!dateStr) return '';
  const [y, m, d] = dateStr.split('-');
  return `${d}-${m}-${y}`;
}
    function showBulkStudentUploadPopup() {
  showPopup(`
    <div class="popup-title">Upload Students (Excel)</div>
    <input type="file" id="studentFileInput" accept=".xlsx,.csv" style="margin-bottom:15px;" />
    <div style="font-size:0.97em; color:#555; margin-bottom:10px;">
      Please upload an Excel (.xlsx) or CSV file with columns:
      <b>Roll, Name, Father, Child ID, ParentPhone</b>. (Child ID and ParentPhone are optional)
    </div>
    <div class="popup-btn-row">
      <button type="button" class="popup-cancel-btn" onclick="closePopup()">Cancel</button>
      <button type="button" class="popup-action-btn" id="doBulkUploadBtn">Upload</button>
    </div>
  `);

  document.getElementById('doBulkUploadBtn').onclick = function() {
    const fileInput = document.getElementById('studentFileInput');
    if (!fileInput.files.length) {
      alert('Please select a file!');
      return;
    }
    const file = fileInput.files[0];
    const reader = new FileReader();

    reader.onload = function(e) {
      try {
        const data = new Uint8Array(e.target.result);
        const workbook = XLSX.read(data, { type: 'array' });
        const sheet = workbook.Sheets[workbook.SheetNames[0]];
        const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });

        if (!rows.length) {
          alert('Empty file.');
          return;
        }

        // Normalize headers
        const headers = rows[0].map(x => x.toString().trim().toLowerCase());

        const nameIdx   = headers.findIndex(h => h === 'name');
        const rollIdx   = headers.findIndex(h => h === 'roll');
        const fatherIdx = headers.findIndex(h => h === 'father');
        const childIdx  = headers.findIndex(h => h === 'child id' || h === 'childid');
        const phoneIdx  = headers.findIndex(h => h.includes('phone'));

        if (nameIdx < 0 || rollIdx < 0 || fatherIdx < 0) {
          alert('Excel must have headers at least: Roll, Name, Father. Optional: Child ID, ParentPhone');
          return;
        }

        const students = [];
        for (let i = 1; i < rows.length; i++) {
          const row = rows[i];
          // Skip completely blank lines
          const hasAny = row.some(cell => (cell !== null && cell !== undefined && String(cell).trim() !== ''));
          if (!hasAny) continue;

          const name = (row[nameIdx] ?? '').toString().trim();
          const father = (row[fatherIdx] ?? '').toString().trim();
          const rollRaw = row[rollIdx];
          const roll = (rollRaw === null || rollRaw === undefined) ? '' : rollRaw.toString().trim();
          const childId = childIdx >= 0 ? (row[childIdx] ?? '').toString().trim() : '';
          const parentPhone = phoneIdx >= 0 ? (row[phoneIdx] ?? '').toString().trim() : '';

          if (!name || !father || !roll) {
            // Soft-skip invalid row
            console.warn(`Row ${i+1} skipped: missing required fields (Roll, Name, Father).`);
            continue;
          }

          // If you prefer numeric roll, uncomment next line:
          // const rollNum = Number.isFinite(parseInt(roll, 10)) ? parseInt(roll, 10) : roll;

          students.push({
            name,
            father,
            childId,       // NEW
            roll,          // keep as string to avoid XLSX numeric formatting issues
            parentPhone
          });
        }

        if (students.length === 0) {
          alert('No valid students found!');
          return;
        }

        // Firestore batch save
        const batch = db.batch();
        const sectionRef = db
          .collection('years').doc(academicYear)
          .collection('classes').doc(currentClassId)
          .collection('sections').doc(currentSectionId)
          .collection('students');

        students.forEach(stu => {
          const ref = sectionRef.doc();
          batch.set(ref, stu);
        });

        batch.commit()
          .then(() => {
            alert('All students uploaded!');
            closePopup();
            renderStudentList && renderStudentList();
          })
          .catch(e => {
            alert('Error uploading students: ' + e.message);
          });

      } catch (err) {
        alert('Failed to read the file: ' + err.message);
      }
    };

    reader.readAsArrayBuffer(file);
  };
}
    // ---- Absentees Modal Open/Close ----
function openAbsenteesModal() {
  document.getElementById('absenteesModalBg').style.display = 'flex';
  document.getElementById('absenteesIframe').src = 'absentees-report.html';
}

function closeAbsenteesModal() {
  document.getElementById('absenteesModalBg').style.display = 'none';
  document.getElementById('absenteesIframe').src = '';
}
  </script>
  <!-- Absentees Report Modal -->
<div id="absenteesModalBg" style="display:none;position:fixed;left:0;top:0;right:0;bottom:0;background:#0007;z-index:2003;align-items:center;justify-content:center;">
  <div id="absenteesModalContent" style="background:#fff;border-radius:16px;box-shadow:0 8px 30px #0f3d6b22;padding:0;min-width:320px;max-width:97vw;width:780px;display:flex;flex-direction:column;gap:0;align-items:stretch;">
    <div style="display:flex;align-items:center;justify-content:space-between;padding:18px 24px 10px 18px;">
      <span style="font-size:1.23em;font-weight:700;color:#0f3d6b;">Absentees Report</span>
      <button id="closeAbsenteesModal" style="background:none;border:none;font-size:1.55em;color:#0f3d6b;cursor:pointer;padding:0 8px;">&times;</button>
    </div>
    <iframe id="absenteesIframe" src="" style="border:none;width:100%;height:75vh;border-radius:0 0 16px 16px;"></iframe>
  </div>
</div>
   <script>
  document.getElementById('closeAbsenteesModal').onclick = closeAbsenteesModal;
  document.getElementById('absenteesModalBg').onclick = function(e) {
    if (e.target === this) closeAbsenteesModal();
  };

    // ---- Upload marks Ecell ----
        function showBulkMarksUploadPopup() {
  db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
    .collection('exams').doc('classGroups')
    .collection(getClassGroupName(currentClassName)).orderBy('name').get()
    .then(examSnap => {
      let exams = [];
      examSnap.forEach(doc => exams.push({ id: doc.id, ...doc.data() }));
      if (exams.length === 0) {
        showPopup(`<div class="popup-title">Upload Marks</div>
          <div style="margin:16px 0;">No exams found! Please add exams first.</div>
          <div class="popup-btn-row"><button class="popup-cancel-btn">Close</button></div>
        `);
        return;
      }
     let html = `
        <div class="popup-title">Upload Marks (Excel)</div>
      
        <label>Select Exam</label>
        <div class="custom-dropdown" id="examDropdown" tabindex="0">
          <div class="dropdown-selected" id="examSelected" data-value="">Select Exam</div>
          <div class="dropdown-list" id="examList" style="display:none;"></div>
        </div>
      
        <input type="file" id="marksFileInput" accept=".xls,.xlsx" style="margin:12px 0 15px 0;" />
      
        <div style="font-size:0.97em; color:#555; margin-bottom:12px;">
          Please upload the Evalbee Excel file.<br>
          You can manually map columns below. Enter column letters like <b>A</b>, <b>B</b>, <b>C</b>â€¦
        </div>
      
        <!-- Manual Column Mapping card -->
        <div style="border:1px solid #e6eef6; border-radius:10px; padding:10px; margin-bottom:12px;">
          <div style="font-weight:600; margin-bottom:8px;">Manual Column Mapping</div>
      
          <!-- Roll mapping (always visible) -->
          <div style="display:grid; grid-template-columns:140px 1fr; gap:8px; align-items:center; margin-bottom:6px;">
            <div>Roll</div>
           <input type="text" id="rollColInput" placeholder="A, B, Câ€¦" maxlength="3"
             style="padding:8px 10px; border:1px solid #ccd7e1; border-radius:8px;">
          </div>
      
          <!-- Subjects mapping (populated after exam selection) -->
          <div id="colMapArea" style="margin-top:8px;">
            <div style="font-size:0.9em; color:#777;">Select an exam to load subject mappingsâ€¦</div>
          </div>
      
          <div style="margin-top:10px;">
            <label style="display:flex; align-items:center; gap:8px; font-size:0.92em;">
              <input type="checkbox" id="rememberMapChk">
              Remember this mapping for this exam & section
            </label>
          </div>
        </div>
      
        <div class="popup-btn-row">
          <button type="button" class="popup-cancel-btn">Cancel</button>
          <button type="button" class="popup-action-btn" id="doBulkMarksUploadBtn">Upload</button>
        </div>
      `;
      showPopup(html);

// ==== Live mapping preview & badges ====
const previewState = { headers: null, sample: null };

// letters/numbers -> 0-based index
function colToIndex(s) {
  if (!s) return -1;
  s = String(s).trim();
  if (/^\d+$/.test(s)) return Math.max(0, parseInt(s, 10) - 1); // 1-based -> 0-based
  let sum = 0;
  for (let i = 0; i < s.length; i++) {
    const ch = s[i].toUpperCase();
    if (ch < 'A' || ch > 'Z') continue;
    sum = sum * 26 + (ch.charCodeAt(0) - 64);
  }
  return sum > 0 ? (sum - 1) : -1;
}

// ensure a hint <div> exists just after the input
function ensureHintEl(inputEl) {
  let hint = inputEl.nextElementSibling;
  if (!hint || !hint.classList || !hint.classList.contains('mapHint')) {
    hint = document.createElement('div');
    hint.className = 'mapHint';
    hint.style.fontSize = '0.85em';
    hint.style.marginTop = '4px';
    hint.style.color = '#777';
    inputEl.parentElement.appendChild(hint);
  }
  return hint;
}

function setHint(inputEl, msg, ok = null) {
  const hint = ensureHintEl(inputEl);
  if (!msg) {
    hint.textContent = '';
    hint.style.display = 'none';
    return;
  }
  hint.style.display = 'block';
  hint.textContent = msg;
  if (ok === true) { hint.style.color = '#137333'; }       // green
  else if (ok === false) { hint.style.color = '#d43f3a'; } // red
  else { hint.style.color = '#777'; }                      // neutral
}

function updateOne(inputEl) {
  if (!inputEl) return;
  const val = (inputEl.value || '').trim();
  const idx = colToIndex(val);
  if (!val) {
  setHint(inputEl, '', null); // no helper line when empty
  return;
}
  if (idx < 0) {
    setHint(inputEl, 'Invalid column', false);
    return;
  }
  // If we don't have a loaded file preview yet
  if (!previewState.headers) {
    setHint(inputEl, `Column #${idx + 1}`, true);
    return;
  }
  const maxIdx = previewState.headers.length - 1;
  if (idx > maxIdx) {
    setHint(inputEl, `Out of range (max ${maxIdx + 1})`, false);
    return;
  }
  const headerTxt = (previewState.headers[idx] || '').toString();
  const sample = previewState.sample ? previewState.sample[idx] : '';
  const sampleStr = (sample !== undefined && sample !== null) ? String(sample) : '';
  const msg = sampleStr
    ? `OK â€¢ Header: "${headerTxt || '-'}" â€¢ Sample: "${sampleStr.slice(0, 30)}"`
    : `OK â€¢ Header: "${headerTxt || '-'}"`;
  setHint(inputEl, msg, true);
}

function updateAllHints() {
  const rollEl = popupContent.querySelector('#rollColInput');
  const subs = Array.from(popupContent.querySelectorAll('.colInput'));
  updateOne(rollEl);
  subs.forEach(el => updateOne(el));
}

function attachMapListeners() {
  const rollEl = popupContent.querySelector('#rollColInput');
  const subs = Array.from(popupContent.querySelectorAll('.colInput'));
  if (rollEl) rollEl.addEventListener('input', () => updateOne(rollEl));
  subs.forEach(el => el.addEventListener('input', () => updateOne(el)));
  // Initial render of hints (for prefilled mappings)
  updateAllHints();

  // --- Custom subtopic dropdowns ---
  const dropdowns = Array.from(popupContent.querySelectorAll('.subtopicDropdown'));
  dropdowns.forEach(dd => {
    const display = dd.querySelector('.subtopicDisplay');
    const menu = dd.querySelector('.subtopicMenu');
    const hidden = dd.querySelector('.subtopicValue');
    if (!display || !menu || !hidden) return;

    // initial label
    display.textContent = hidden.value || 'Select Subtopic';

    display.onclick = (ev) => {
      ev.stopPropagation();
      const openNow = menu.style.display === 'block';
      // close all menus in this popup
      popupContent.querySelectorAll('.subtopicMenu').forEach(m => { m.style.display = 'none'; });
      menu.style.display = openNow ? 'none' : 'block';
    };

    Array.from(menu.querySelectorAll('.subtopicOption')).forEach(opt => {
      opt.onclick = (ev) => {
        ev.stopPropagation();
        const val = opt.dataset.value || '';
        hidden.value = val;
        display.textContent = val || 'Select Subtopic';
        menu.style.display = 'none';
      };
    });
  });

  // Click outside closes menus
  document.addEventListener('click', () => {
    const menus = popupContent.querySelectorAll('.subtopicMenu');
    menus.forEach(m => { m.style.display = 'none'; });
  }, { once: true });
}


// load a lightweight preview (headers + 2nd row) when a file is chosen
function loadPreviewFromFile(file) {
  return new Promise(resolve => {
    const r = new FileReader();
    r.onload = e => {
      try {
        const data = new Uint8Array(e.target.result);
        const wb = XLSX.read(data, { type: 'array' });
        const sheet = wb.Sheets[wb.SheetNames[0]];
        const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
        if (rows && rows.length) {
          previewState.headers = rows[0].map(x => String(x).trim());
          previewState.sample = rows[1] || [];
          updateAllHints();
        }
      } catch (err) {
        console.warn('Preview parse error:', err);
      }
      resolve();
    };
    r.readAsArrayBuffer(file);
  });
}

// hook file input to build preview
const marksFileInput = popupContent.querySelector('#marksFileInput');
if (marksFileInput) {
  marksFileInput.addEventListener('change', (ev) => {
    const f = ev.target.files && ev.target.files[0];
    if (f) loadPreviewFromFile(f);
  });
}
      // Populate exam dropdown
      const examDropdown = popupContent.querySelector('#examDropdown');
      const examSelected = popupContent.querySelector('#examSelected');
      const examList = popupContent.querySelector('#examList');
      examList.innerHTML = exams.map(e => `
        <div class="dropdown-option" data-id="${e.id}" style="padding:10px 12px;cursor:pointer;">
          ${e.name}
        </div>
      `).join('');
      examSelected.onclick = function () {
        examList.style.display = (examList.style.display === 'none' || examList.style.display === '') ? 'block' : 'none';
      };
      document.addEventListener('click', function handler(e) {
        if (!examDropdown.contains(e.target)) {
          examList.style.display = 'none';
          document.removeEventListener('click', handler);
        }
      });
      let selectedExam = null;
      examList.querySelectorAll('.dropdown-option').forEach(opt => {
  opt.onclick = function () {
    examSelected.textContent = this.textContent;
    examSelected.dataset.value = this.dataset.id;
    examList.style.display = 'none';
    selectedExam = exams.find(e => e.id === this.dataset.id);

    // === Build the subject column-mapping inputs ===
    const colMapArea = popupContent.querySelector('#colMapArea');
    const rollInput = popupContent.querySelector('#rollColInput');
    const rememberChk = popupContent.querySelector('#rememberMapChk');

    // Load any saved mapping for this exam/section (optional)
    const storageKey = `colmap_${academicYear}_${currentClassId}_${currentSectionId}_${selectedExam.id}`;
    let saved = null;
    try { saved = JSON.parse(localStorage.getItem(storageKey) || 'null'); } catch(e){ saved = null; }

    // Prefill Roll (default A if nothing saved)
    if (rollInput) rollInput.value = (saved && saved.roll) ? saved.roll : (rollInput.value || '');

    // Build rows for each subject
    if (!selectedExam || !Array.isArray(selectedExam.subjects) || selectedExam.subjects.length === 0) {
      colMapArea.innerHTML = `<div style="font-size:0.9em; color:#777;">No subjects defined for this exam.</div>`;
      return;
    }

                   let rowsHtml = selectedExam.subjects.map(subj => {
      // Backward-compatible preset (string or { col, subtopic })
      let presetCol = '';
      let presetSub = '';
      if (saved && saved.subjects && saved.subjects[subj.name]) {
        const sv = saved.subjects[subj.name];
        if (typeof sv === 'string') {
          presetCol = sv;
        } else {
          presetCol = sv.col || '';
          presetSub = sv.subtopic || '';
        }
      }

            // --------- Resolve subtopics for this subject ----------
      // Modes:
      //   subj.subtopicsMode === 'custom'  -> use subj.subtopics
      //   subj.subtopicsMode === 'common'/'comman' -> use exam-level common subtopics
      //   'none' or missing -> no subtopics
      let effectiveSubs = [];

      const mode = (subj.subtopicsMode || selectedExam.subtopicsMode || '').toLowerCase();

      if (mode === 'custom' && Array.isArray(subj.subtopics) && subj.subtopics.length) {
        // per-subject custom subtopics
        effectiveSubs = subj.subtopics;
      } else if (mode === 'common' || mode === 'comman') {
        // exam-level common subtopics (support a few possible field names)
        const examSubsRaw =
          (Array.isArray(selectedExam.subtopics) && selectedExam.subtopics) ||
          (Array.isArray(selectedExam.subtopicsCommon) && selectedExam.subtopicsCommon) ||
          (Array.isArray(selectedExam.commonSubtopics) && selectedExam.commonSubtopics) ||
          [];
        if (examSubsRaw.length) {
          effectiveSubs = examSubsRaw;
        }
      }
      // else: mode is 'none' or no subtopics -> leave effectiveSubs = []

           const flatSubs = effectiveSubs
        .map(st => {
          if (typeof st === 'string') return st;
          if (!st || typeof st !== 'object') return '';
          return st.name || st.label || st.title || st.text || '';
        })
        .filter(Boolean);

      const hasSubs = flatSubs.length > 0;

           let subtopicCellHtml = '';
      if (hasSubs) {
        const optionHtml = flatSubs.map(st => `
          <div class="subtopicOption" data-value="${st}"
               style="padding:8px 10px; font-size:0.94em; cursor:pointer;">
            ${st}
          </div>`).join('');

        const displayText = presetSub || '--Select subtopic--';

        subtopicCellHtml = `
          <div class="subtopicRow" style="margin-top:6px;">
            <div class="subtopicDropdown" data-subject="${subj.name}"
                 style="position:relative; width:100%;">
              <div class="subtopicDisplay"
                   style="padding:9px 11px; border:1px solid #ccd7e1; border-radius:10px; background:#f4f7fb; font-size:0.94em;">
                ${displayText}
              </div>
              <div class="subtopicMenu"
                   style="display:none; position:absolute; left:0; right:0; top:100%; margin-top:4px; background:#fff; border:1px solid #ccd7e1; border-radius:10px; max-height:220px; overflow-y:auto; box-shadow:0 6px 18px rgba(0,0,0,0.16); z-index:50;">
                ${optionHtml}
              </div>
              <input type="hidden" class="subtopicValue" data-subject="${subj.name}" value="${presetSub}">
            </div>
          </div>`;
      }

      return `
        <div class="mapRow" style="border:1px solid #e6eef6; border-radius:10px; padding:8px 10px; margin-bottom:8px; background:#f9fbff;">
          <div style="display:grid; grid-template-columns:120px 1fr; gap:8px; align-items:center;">
            <div style="font-size:0.95em; color:#333;">${subj.name}</div>
            <input type="text" class="colInput" data-subject="${subj.name}" data-has-subs="${hasSubs ? '1' : '0'}"
         placeholder="A, B, Câ€¦" value="${presetCol}" maxlength="3"
         style="width:100%; padding:9px 11px; border:1px solid #ccd7e1; border-radius:10px; background:#f4f7fb;">
          </div>
          ${subtopicCellHtml}
        </div>
      `;

    }).join('');

    colMapArea.innerHTML = rowsHtml;
    attachMapListeners();

    // Prefill the "remember" toggle based on saved state (default off)
    if (rememberChk) rememberChk.checked = !!(saved && saved.remember === true);
  };
});
      document.getElementById('doBulkMarksUploadBtn').onclick = async function () {
  const fileInput = document.getElementById('marksFileInput');
  if (!fileInput.files.length) return alert('Please select a file!');
  if (!selectedExam) return alert('Please select an exam!');

  // === Read manual mapping from the popup ===
  const rollColStr = (popupContent.querySelector('#rollColInput')?.value || '').trim();
  if (!rollColStr) return alert('Please enter the Roll column (e.g., A).');

  const colInputs = Array.from(popupContent.querySelectorAll('.colInput'));
  const rememberChk = popupContent.querySelector('#rememberMapChk');
  const storageKey = `colmap_${academicYear}_${currentClassId}_${currentSectionId}_${selectedExam.id}`;

  // Letter(s)/number -> zero-based column index
  function colToIndex(s) {
    if (!s) return -1;
    s = String(s).trim();
    // numeric 1-based (e.g., "3" -> index 2)
    if (/^\d+$/.test(s)) return Math.max(0, parseInt(s, 10) - 1);
    // letters (e.g., "A" -> 0, "AA" -> 26)
    let sum = 0;
    for (let i = 0; i < s.length; i++) {
      const ch = s[i].toUpperCase();
      if (ch < 'A' || ch > 'Z') continue;
      sum = sum * 26 + (ch.charCodeAt(0) - 64);
    }
    return sum > 0 ? (sum - 1) : -1;
  }

  const file = fileInput.files[0];
  const reader = new FileReader();
  reader.onload = async function (e) {
    const data = new Uint8Array(e.target.result);
    const workbook = XLSX.read(data, { type: 'array' });
    const sheet = workbook.Sheets[workbook.SheetNames[0]];
    const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });

    if (!rows || rows.length < 2) {
      alert('The Excel sheet appears empty or missing data rows.');
      return;
    }

    const headers = rows[0].map(x => String(x).trim().toLowerCase());
    const lastColIndex = headers.length - 1;

    // Build indexes from manual inputs
    const rollIdx = colToIndex(rollColStr);
    if (rollIdx < 0 || rollIdx > lastColIndex) {
      alert(`Roll column "${rollColStr}" is invalid or out of range. Sheet has ${headers.length} columns.`);
      return;
    }

              const colIndexes = {};
    const subtopicMap = {};
    const unmappedSubjects = [];   // left blank by user
    const invalidSubjects = [];    // invalid/out-of-range inputs
    const missingSubtopicSubjects = []; // column set but no subtopic chosen when required

    selectedExam.subjects.forEach(subj => {
        const el = colInputs.find(inp => inp.dataset.subject === subj.name);
        const v = (el?.value || '').trim();
        const subHidden = popupContent.querySelector(`.subtopicValue[data-subject="${subj.name}"]`);
        const subVal = (subHidden && subHidden.value) ? subHidden.value : '';

      const hasSubsFlag = el && el.dataset && el.dataset.hasSubs === '1';
      const requiresSub = !!hasSubsFlag;

      if (!v) {
        unmappedSubjects.push(subj.name);
        colIndexes[subj.name] = -1;
        subtopicMap[subj.name] = subVal || '';
      } else {
        const idx = colToIndex(v);
        if (idx < 0 || idx > lastColIndex) {
          invalidSubjects.push(`${subj.name} (${v})`);
          colIndexes[subj.name] = -1;
        } else {
          colIndexes[subj.name] = idx;
          subtopicMap[subj.name] = subVal || '';
          if (requiresSub && !subVal) {
            missingSubtopicSubjects.push(subj.name);
          }
        }
      }
    });

    if (invalidSubjects.length > 0) {
      alert(`These subject columns are invalid/out of range:\nâ€¢ ${invalidSubjects.join('\nâ€¢ ')}`);
      return;
    }

    if (missingSubtopicSubjects.length > 0) {
      alert(`Please choose a subtopic for these subjects:\nâ€¢ ${missingSubtopicSubjects.join('\nâ€¢ ')}`);
      return;
    }

        // Optionally remember this mapping
    if (rememberChk && rememberChk.checked) {
      const saveObj = {
        remember: true,
        roll: rollColStr.toUpperCase(),
        subjects: {}
      };
      selectedExam.subjects.forEach(subj => {
        const el = colInputs.find(inp => inp.dataset.subject === subj.name);
        const v = (el?.value || '').trim();
        const subSel = popupContent.querySelector(`.subtopicSelect[data-subject="${subj.name}"]`);
        const subVal = (subSel && subSel.value) ? subSel.value : '';
        if (v || subVal) {
          saveObj.subjects[subj.name] = {
            col: v ? v.toUpperCase() : '',
            subtopic: subVal
          };
        }
      });
      try { localStorage.setItem(storageKey, JSON.stringify(saveObj)); } catch (_) {}
    }

    // === Fetch students ===
    const stuSnap = await db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
      .collection('classes').doc(currentClassId)
      .collection('sections').doc(currentSectionId)
      .collection('students').orderBy('roll').get();

    const students = [];
    stuSnap.forEach(doc => students.push({ id: doc.id, ...doc.data() }));

    const batch = db.batch();
    let updates = 0;
    const matchedRolls = [];
    const notFoundRolls = [];

    for (let i = 1; i < rows.length; i++) {
      const row = rows[i];
      const roll = parseInt(row[rollIdx]);
      if (isNaN(roll)) continue;

      const stu = students.find(s => parseInt(s.roll) === roll);
      if (!stu) {
        notFoundRolls.push(roll);
        continue;
      }
      matchedRolls.push(roll);

           const marksObj = {};
      selectedExam.subjects.forEach(subj => {
        const idx = colIndexes[subj.name];
        if (idx >= 0) {
          const val = row[idx];
          const num = Number(val);
          const mark = isNaN(num) ? 0 : num;

                    const subtopicName = subtopicMap[subj.name] || '';
          const shouldUseSub = !!subtopicName;

          if (shouldUseSub) {
            if (!marksObj.__subs) marksObj.__subs = {};
            if (!marksObj.__subs[subj.name]) marksObj.__subs[subj.name] = {};
            marksObj.__subs[subj.name][subtopicName] = mark;
          } else {
            // fall back to top-level subject total
            marksObj[subj.name] = mark;
          }
        }
      });

      const markRef = db.collection('schools').doc(schoolId).collection('years').doc(academicYear)
        .collection('classes').doc(currentClassId)
        .collection('sections').doc(currentSectionId)
        .collection('students').doc(stu.id)
        .collection('marks').doc(selectedExam.id);

      batch.set(markRef, marksObj, { merge: true });
      updates++;
    }

    if (updates === 0) {
      alert('No matching students found by roll number!');
      return;
    }

    await batch.commit();

    // --- Build the Summary Message ---
    let summary = `<div class="popup-title">Upload Summary</div>
      <div style="font-size:1.1em;margin-bottom:7px;"><b>${updates}</b> students updated!</div>`;

    if (matchedRolls.length > 0) {
      summary += `<div><b>Matched Roll Numbers:</b><br>
        <span style="font-size:.97em;">${matchedRolls.sort((a,b)=>a-b).join(', ')}</span></div>`;
    }
    if (notFoundRolls.length > 0) {
      summary += `<div style="margin-top:9px;"><b>Roll Numbers NOT found:</b><br>
        <span style="color:#d43f3a;">${notFoundRolls.sort((a,b)=>a-b).join(', ')}</span></div>`;
    }
    if (unmappedSubjects.length > 0) {
      summary += `<div style="margin-top:10px;"><b>Subjects not mapped (left blank):</b><br>
        <span style="color:#d43f3a;">${unmappedSubjects.join(', ')}</span>
        <br><span style="font-size:.97em;color:#999;">These subjects were skipped.</span></div>`;
    }

    summary += `<div class="popup-btn-row" style="margin-top:18px;">
      <button class="popup-action-btn">Close</button></div>`;

    showPopup(summary);
    setTimeout(() => {
      const closeBtn = popupContent.querySelector('.popup-action-btn');
      if (closeBtn) closeBtn.onclick = closePopup;
    }, 100);
  };
  reader.readAsArrayBuffer(file);
};
    });
}
</script>
</body>
</html>
